//Find new operations completed by your privileged Azure AD users not seen before

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

//Lookup the IdentityInfo table for any users holding a privileged role
let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
//Find actions taken by those users previously
AuditLogs
| where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(UserPrincipalName)
| where UserPrincipalName in (privusers)
| distinct UserPrincipalName, OperationName
//Find any new actions taken in the last day not seen before from that user
| join kind=rightanti (
    AuditLogs
    | where TimeGenerated > ago(1d)
    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where UserPrincipalName in (privusers)
    | where isnotempty(UserPrincipalName)
    )
    on UserPrincipalName, OperationName
| project TimeGenerated, UserPrincipalName, OperationName, Category, CorrelationId
//Find any single factor sign ins to Azure resources such as the Azure portal

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(7d)
| where AppDisplayName has "Azure"
| where ResultType == 0
| where AuthenticationRequirement == "singleFactorAuthentication"
| summarize ['Single Factor Authentications']=make_set(UserPrincipalName) by AppDisplayName
| extend ['User Count'] = array_length(['Single Factor Authentications'])
| order by ['User Count'] desc

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(7d)
| where Application has "Azure"
| where ErrorCode == 0
| where LogonType == @"[""interactiveUser""]"
| where AuthenticationRequirement == "singleFactorAuthentication"
| summarize ['Single Factor Authentications']=make_set(AccountUpn) by Application
| extend ['User Count'] = array_length(['Single Factor Authentications'])
| order by ['User Count'] desc
//Finds users who hold a privileged Azure Active Directory role who are signing into applications using single factor

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
SigninLogs
| where TimeGenerated > ago(30d)
| where UserPrincipalName in~ (privusers)
| where ResultType == 0
| where AuthenticationRequirement == "singleFactorAuthentication"
| summarize
    ['List of Applications']=make_set(AppDisplayName),
    ['Count of Applications']=dcount(AppDisplayName)
    by UserPrincipalName
| sort by ['Count of Applications'] desc 
//Visualize password vs passwordless signins per day

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (180d)
| mv-expand todynamic(AuthenticationDetails)
| project TimeGenerated, AuthenticationDetails
| extend AuthMethod = tostring(AuthenticationDetails.authenticationMethod)
| summarize
    Passwordless=countif(AuthMethod in ("Windows Hello for Business", "Passwordless phone sign-in", "FIDO2 security key", "X.509 Certificate")),
    Password=countif(AuthMethod == "Password")
    by bin(TimeGenerated, 1d)
| render timechart with (title="Passwordless vs Password Authentication", ytitle="Count")
//Summarize your Azure AD apps by what permissions they currently hold

//Data connector required for this query - Azure Active Directory - Audit Logs

//Find applications that have been deleted
let deletedapps=
AuditLogs
| where OperationName == "Remove service principal"
| extend ServicePrincipalId = tostring(TargetResources[0].id)
| project ServicePrincipalId;
let delegatedaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add delegated permission grant"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | extend ['Permission type'] = strcat("Delegated")
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
//Exclude deleted applications
    | where ServicePrincipalId !in (deletedapps)
    | project
        TimeGenerated,
        ['Permission type'],
        ['Permissions granted'],
        ServicePrincipalId;
let appaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add app role assignment to service principal"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ['Permission type'] = strcat("Application")
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
//Exclude deleted applications
    | where ServicePrincipalId !in (deletedapps)
    | project
        TimeGenerated,
        ServicePrincipalId,
        ['Permission type'],
        ['Permissions granted'];
union delegatedaccess, appaccess
| mv-expand ['Permissions granted']
| where isnotempty( ['Permissions granted'])
//Extend new permission field
| summarize ['Permission List']=make_set(['Permissions granted']) by ['Permission type'], ServicePrincipalId
| extend ['Number of Permissions']=array_length(['Permission List']) 
| sort by ServicePrincipalId desc, ['Permission type'] asc
//Query to find users who have access to an application but haven't signed in for 90 days

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let signins=
SigninLogs
| where TimeGenerated > ago (90d)
| where AppDisplayName has "Application Name"
| project TimeGenerated, UserPrincipalName, AppDisplayName;
IdentityInfo
| where TimeGenerated > ago (21d)
| summarize arg_max(TimeGenerated, *) by AccountUPN
| extend UserPrincipalName = AccountUPN
| where GroupMembership contains "Group that gives access to Application"
| join kind=leftanti signins on UserPrincipalName
| project UserPrincipalName
//Find when inbound Azure AD guests access applications for the first time

//Data connector required for this query - Azure Active Directory - Signin Logs

//First find applications that have previously had Azure AD guest signins
let knownapps=
    SigninLogs
    | where TimeGenerated > ago (90d) and TimeGenerated < ago(7d)
    | where ResultType == 0
    | where UserType == "Guest"
//Include only inbound guests (guests accessing your tenant)
    | where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
    | distinct AppDisplayName;
//Lookup signins from the last week and find guest sign ins to applications not on the known list
SigninLogs
| where TimeGenerated > ago (7d)
| where ResultType == 0
| where UserType == "Guest"
| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
| where AppDisplayName !in (knownapps)
//Summarize the access to those applications by time first seen and who is accessing each application
| summarize
    ['First Logon Time']=min(TimeGenerated),
    ['Total Guest Signins']=count(),
    ['Distinct Guest Signins']=dcount(UserPrincipalName),
    ['List of Guest Users']=make_set(UserPrincipalName)
    by AppDisplayName
//Detects users who have added a credential to an Azure AD App for the first time in 90 days, adjust timeframe as needed.

//Data connector required for this query - Azure Active Directory - Audit Logs

let timeframe = startofday(ago(90d));
AuditLogs
| where TimeGenerated > timeframe and TimeGenerated < startofday(now())
| where OperationName has "Update application – Certificates and secrets management"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project Actor
| join kind=rightanti
    (
    AuditLogs
    | where TimeGenerated > startofday(now())
    | where OperationName has "Update application – Certificates and secrets management"
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend AppId = tostring(AdditionalDetails[1].value)
    | project TimeGenerated, Actor, AppId
    )
    on Actor
| project TimeGenerated, Actor, AppId
//Summarize your Azure AD service principals by the last time they signed in, grouped by month

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| project TimeGenerated, AppId, ResultType, ServicePrincipalName
| where TimeGenerated > ago (360d)
| where ResultType == 0
| summarize arg_max(TimeGenerated, *) by AppId
| summarize ['Application List']=make_set(ServicePrincipalName) by Month=startofmonth(TimeGenerated)
| sort by Month asc 
//Alert when the redirect URI list is changed for a service principal

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Update service principal"
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties 
| where modifiedProperties.displayName == "AppAddress" 
| extend newValue = tostring(parse_json(modifiedProperties).newValue)
| mv-expand todynamic(newValue)
| extend RedirectURI = tostring(newValue.Address)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Service Principal Name'] = tostring(TargetResources.displayName)
| summarize ['List of Redirect URIs']=make_list(RedirectURI) by Actor, ['Service Principal Name']
//Alert when an application using Azure AD app proxy is set to pass through as it's pre-auth setting
AuditLogs
| where LoggedByService == "Application Proxy"
| where OperationName == "Update application"
| where Result == "success"
| extend PreAuthSetting = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
| where PreAuthSetting == "Passthru"
| extend ['App Display Name'] = tostring(TargetResources[0].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project TimeGenerated, PreAuthSetting, ['App Display Name'], Actor, ['Actor IP Address']
//Visualizes the total guest invites sent from your Azure AD tenant vs those redeemed. Data is summarized per week.

//Data connector required for this query - Azure Active Directory - Audit Logs

let timerange=180d;
AuditLogs
| where TimeGenerated > ago (timerange)
| where OperationName in ("Redeem external user invite", "Invite external user")
| summarize
    InvitesSent=countif(OperationName == "Invite external user"),
    InvitesRedeemed=countif(OperationName == "Redeem external user invite")
    by startofweek(TimeGenerated)
| render columnchart
    with (
    title="Guest Invites Sent v Guest Invites Redeemed",
    xtitle="Invites",
    kind=unstacked)
//Calculate the percentage of signins to each of your Azure AD applications that used MFA

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| summarize
    ['Total Signin Count']=count(),
    ['Total MFA Count']=countif(AuthenticationRequirement == "multiFactorAuthentication"),
    ['Total non MFA Count']=countif(AuthenticationRequirement == "singleFactorAuthentication")
    by AppDisplayName
| project
    AppDisplayName,
    ['Total Signin Count'],
    ['Total MFA Count'],
    ['Total non MFA Count'],
    MFAPercentage=(todouble(['Total MFA Count']) * 100 / todouble(['Total Signin Count']))
| sort by ['Total Signin Count'] desc, MFAPercentage asc  
//Investigate potentially suspicious IP addresses for your Azure AD signins. This query lists any IP address with more failures than successful connections and provides a summary for each with at least one successful signin.
//This may uncover password spray attacks that have had a successful connections.

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType in(successCodes) or ResultType in(failureCodes)
| summarize
    ['Count of successful signins'] = countif((ResultType in(successCodes))),
    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),
    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),
    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),
    ['Count of failed signins']=countif((ResultType in(failureCodes))),
    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),
    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),
    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes))),
    ['First successful login'] = maxif(TimeGenerated, (ResultType in(successCodes)))
    by IPAddress
//Exclude IP addresses with more successful signins than failed. This is a good way to exclude known locations as they will have lots of failures too, but they will be balanced by more successes.
//Then find IP addresses with 5 or more distinct failed signins and at least one successful signin
| where ['Count of failed signins'] > ['Count of successful signins'] and ['Count of distinct failed sign ins'] > ['Count of distinct successful sign ins'] and ['Count of distinct failed sign ins'] >= 5 and ['Count of distinct successful sign ins'] >= 1
| order by ['Count of distinct successful sign ins'] desc

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//Advanced Hunting query
let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
AADSignInEventsBeta
| where Timestamp > ago(7d)
| where ErrorCode in(successCodes) or ErrorCode in(failureCodes)
| summarize
    ['Count of successful signins'] = countif((ErrorCode in(successCodes))),
    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),
    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),
    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),
    ['Count of failed signins']=countif((ErrorCode in(failureCodes))),
    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),
    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),
    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes))) 
    by IPAddress
//Exclude IP addresses with more successful signins than failed. This is a good way to exclude known locations as they will have lots of failures too, but they will be balanced by more successes.
//Then find IP addresses with 5 or more distinct failed signins and at least one successful signin
| where ['Count of failed signins'] > ['Count of successful signins'] and ['Count of distinct failed sign ins'] > ['Count of distinct successful sign ins'] and ['Count of distinct failed sign ins'] >= 5 and ['Count of distinct successful sign ins'] >= 1
| order by ['Count of distinct successful sign ins'] desc 

//Detects when an Azure AD guest is added to an Azure AD role

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Add member to role"
| extend Target = tostring(TargetResources[0].userPrincipalName)
| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where Target contains "#ext#"
| project TimeGenerated, OperationName, Actor, Target, RoleAdded
//Summarize signins to your Azure AD tenant still using Internet Explorer. Data is grouped into each user and which applications they are accessing.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where ResultType == 0
| extend UserAgentDetail = todynamic(parse_user_agent(UserAgent, "browser"))
| extend UserAgentFamily = tostring(parse_json(tostring(UserAgentDetail.Browser)).Family)
| extend UserAgentMajorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MajorVersion)
| extend UserAgentMinorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MinorVersion)
| extend UserAgentPatch = toint(parse_json(tostring(UserAgentDetail.Browser)).Patch)
| project
    TimeGenerated,
    UserPrincipalName,
    AppDisplayName,
    ResultType,
    IPAddress,
    Location,
    UserAgentFamily,
    UserAgentMajorVersion,
    UserAgentMinorVersion,
    UserAgentPatch,
    UserAgent
| where UserAgentFamily == "IE"
| summarize ['Total IE Signins']=count(), ['Count of Applications']=dcount(AppDisplayName), ['List of Applications']=make_set(AppDisplayName) by UserPrincipalName
| sort by ['Count of Applications'] desc 
//Tracks privileged post creation events on your Azure AD service principals, such as secrets being generated, permissions being added or an admin consenting.

//Data connector required for this query - Azure Active Directory - Audit Logs

//Events are then summarized by operation and time. Add a specific Application ID to track events for that one app.
let timeframe=60d;
let AppAdded=
    AuditLogs
    | where TimeGenerated > ago (timeframe)
    | where OperationName == "Add service principal"
    | extend AppId = tostring(AdditionalDetails[1].value)
    | extend ServicePrincipalId = tostring(TargetResources[0].id)
    // Optionally add a specific Application ID
    //| where AppId == "id"
    | extend AppName = tostring(TargetResources[0].displayName)
    | where isnotempty(AppId)
    | project TimeGenerated, OperationName, AppId, AppName, ServicePrincipalId;
let AppSecretAdded=
    AuditLogs
    | where OperationName contains 'Update application – Certificates and secrets management'
    | extend AppId = tostring(AdditionalDetails[1].value)
    | project TimeGenerated, AppId, OperationName
    | join kind=inner AppAdded on AppId
    | project TimeGenerated, OperationName, AppId, AppName;
let AppApplicationAccess=
    AuditLogs
    | where OperationName == "Add app role assignment to service principal"
    | extend AppId = tostring(TargetResources[1].displayName)
    | project TimeGenerated, AppId, OperationName
    | join kind=inner AppAdded on AppId
    | project TimeGenerated, OperationName, AppId, AppName;
let AppDelegatedAccess=
    AuditLogs
    | where OperationName == "Add delegated permission grant"
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | project TimeGenerated, ServicePrincipalId, OperationName
    | join kind=inner AppAdded on ServicePrincipalId
    | project TimeGenerated, OperationName, AppId, AppName;
let AppConsentGiven=
    AuditLogs
    | where OperationName == "Consent to application"
    | extend AppId = tostring(AdditionalDetails[1].value)
    | project TimeGenerated, AppId, OperationName
    | join kind=inner AppAdded on AppId
    | project TimeGenerated, OperationName, AppId, AppName;
let AppDeleted=
    AuditLogs
    | where OperationName == "Delete application"
    | extend AppId = tostring(AdditionalDetails[1].value)
    | project TimeGenerated, AppId, OperationName
    | join kind=inner AppAdded on AppId
    | project TimeGenerated, OperationName, AppId, AppName;
AppAdded
| union
    AppSecretAdded,
    AppApplicationAccess,
    AppConsentGiven,
    AppDelegatedAccess,
    AppDeleted
| sort by TimeGenerated asc 
| summarize
    AppOperations=(make_list(OperationName)),
    AppOperationTime=(make_list(TimeGenerated))
    by AppId, AppName
//Detect when an Azure AD service principal is created for a managed identity

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Add service principal"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.app)).displayName)
| extend ['Service Principal DisplayName'] = tostring(TargetResources[0].displayName)
| extend ['Service Principal Id'] = tostring(TargetResources[0].id)
| where Actor == "Managed Service Identity"
| project TimeGenerated, ['Service Principal DisplayName'], ['Service Principal Id']
//Find users who are only using text message as their MFA method

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
//You can exclude guests if you want, they may be harder to move to more secure methods, comment out the below line to include all users
| where UserType == "Member"
| mv-expand todynamic(AuthenticationDetails)
| extend ['Authentication Method'] = tostring(AuthenticationDetails.authenticationMethod)
| where ['Authentication Method'] !in ("Previously satisfied", "Password", "Other")
| where isnotempty(['Authentication Method'])
| summarize
    ['Count of distinct MFA Methods']=dcount(['Authentication Method']),
    ['List of MFA Methods']=make_set(['Authentication Method'])
    by UserPrincipalName
//Find users with only one method found and it is text message
| where ['Count of distinct MFA Methods'] == 1 and ['List of MFA Methods'] has "text"
//Visualize the MFA types used by your users - phone sign in, mobile passcode, push or text message, over time

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (180d)
| where AuthenticationRequirement == "multiFactorAuthentication"
| project TimeGenerated, AuthenticationDetails
| extend ['MFA Method'] = tostring(parse_json(AuthenticationDetails)[1].authenticationMethod)
| summarize Count=count()by ['MFA Method'], bin(TimeGenerated, 7d)
| where ['MFA Method'] != "Previously satisfied" and isnotempty(['MFA Method']) 
| render timechart with (ytitle="Count", xtitle="Day", title="MFA methods per week over time")
//When a user holding a privileged role triggers an Azure AD risk event, retrieve the operations completed by that user
//Lookup the IdentityInfo table for any users holding a privileged role

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
AADUserRiskEvents
| where TimeGenerated > ago (7d)
| where UserPrincipalName in (privusers)
| where RiskDetail != "aiConfirmedSigninSafe"
| project RiskTime=TimeGenerated, UserPrincipalName
| join kind=inner
    (
    AuditLogs
    | where TimeGenerated > ago(7d)
    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    )
    on UserPrincipalName
| project-rename OperationTime=TimeGenerated
| project
    RiskTime,
    OperationTime,
    ['Time Between Events']=datetime_diff("minute", OperationTime, RiskTime),
    OperationName,
    Category,
    CorrelationId
//Detect when an Azure AD managed identity accesses a resource for the first time, i.e an identity that previously only accessed storage accesses a key vault

//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs

AADManagedIdentitySignInLogs
| where TimeGenerated > ago (60d) and TimeGenerated < ago(1d)
| where ResultType == "0"
| distinct ServicePrincipalId, ResourceIdentity
| join kind=rightanti (
    AADManagedIdentitySignInLogs
    | where TimeGenerated > ago (1d)
    | where ResultType == "0"
    )
    on ServicePrincipalId, ResourceIdentity
| project
    ['Service Principal DisplayName']=ServicePrincipalName,
    ['Service Principal Id']=ServicePrincipalId,
    ['Azure Resource Identity Id']=ResourceIdentity,
    ['Azure Resource DisplayName']=ResourceDisplayName
| distinct
    ['Service Principal DisplayName'],
    ['Service Principal Id'],
    ['Azure Resource DisplayName'],
    ['Azure Resource Identity Id']
//Query to find security alerts for users who have privileged Azure AD roles

//Data connector required for this query - Microsoft Sentinel UEBA
//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)

let PrivRoles = dynamic(["Global Administrator", "Security Administrator", "Teams Administrator"]);
let identityinfo=
    IdentityInfo
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where AssignedRoles has_any (PrivRoles)
    | extend TargetUserName = AccountName
    | extend UserPrincipalName = AccountUPN
    | project TargetUserName, UserPrincipalName, AssignedRoles;
SecurityAlert
| where TimeGenerated >= ago(5d)
| extend AlertTime = TimeGenerated
| extend UserPrincipalName = CompromisedEntity
| join kind=inner identityinfo on UserPrincipalName
| project AlertTime, TargetUserName, UserPrincipalName, AlertName, AssignedRoles
//Create a pivot table showing all conditional access policy outcomes over the last 30 days

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| extend CA = parse_json(ConditionalAccessPolicies)
| mv-expand bagexpansion=array CA
| evaluate bag_unpack(CA)
| extend
    ['CA Outcome']=tostring(column_ifexists('result', "")),
    ['CA Policy Name'] = column_ifexists('displayName', "")
| evaluate pivot(['CA Outcome'], count(), ['CA Policy Name'])
//Detects when an admin changes the authentication phone details for another user

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Admin updated security info"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend Target = tostring(TargetResources[0].userPrincipalName)
| extend ['New Phone Number'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[2].newValue)))
| extend ['Old Phone Number'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[2].oldValue)))
| project TimeGenerated, Actor, Target, ['New Phone Number'], ['Old Phone Number']
//Find Azure AD applications that have more guests than members accessing them

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel Query
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == "0"
| summarize Guests=dcountif(UserPrincipalName,UserType == "Guest"), Members=dcountif(UserPrincipalName,UserType == "Member") by AppDisplayName
| where Guests > Members
| sort by Guests desc 

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(30d)
| where LogonType == @"[""interactiveUser""]"
| where ErrorCode == "0"
| summarize Guests=dcountif(AccountUpn,IsGuestUser == "true"), Members=dcountif(AccountUpn,IsGuestUser == "false") by Application
| where Guests > Members
| sort by Guests desc 
//Detects when a user registers MFA details on their account and then completes self service password reset with a short timeframe

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - Audit Logs

let timeframe=4h;
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName in~ ("User changed default security info", "User registered all required security info", "User registered security info","Admin registered security info")
| extend User = tostring(TargetResources[0].userPrincipalName)
| project SecurityInfoTime=TimeGenerated, User, OperationName
| join kind=inner (
    AuditLogs
    | where TimeGenerated > ago(1d)
    | where OperationName in ("Reset password (self-service)", "Change password (self-service)")
    | where Result == "success"
    | extend User = tostring(TargetResources[0].userPrincipalName)
    | project PasswordResetTime=TimeGenerated, OperationName, User)
    on User
| where (PasswordResetTime - SecurityInfoTime) between (0min .. timeframe)
//Summarize the count of the various types of MFA failures (such as user not responding, invalid codes, user declining the authentication)

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (90d)
| where ResultType == "500121"
| mv-expand todynamic(AuthenticationDetails)
| project AuthenticationDetails, ResultType
| extend ['MFA Failure Type'] = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
| where ['MFA Failure Type'] startswith "MFA denied"
| summarize Count=count()by ['MFA Failure Type']
| sort by Count

//Find users who hold privileged Azure AD roles but haven't signed onto Azure for 30 days

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let applications = dynamic(["Azure Active Directory PowerShell", "Microsoft Azure PowerShell", "Graph Explorer", "ACOM Azure Website", "Azure Portal", "Azure Advanced Threat Protection"]);
IdentityInfo
| where TimeGenerated > ago(21d)
| where isnotempty(AssignedRoles)
| project-rename UserPrincipalName=AccountUPN
| where AssignedRoles != "[]"
| summarize arg_max(TimeGenerated, *) by UserPrincipalName
| join kind=leftanti (
    SigninLogs
    | where TimeGenerated > ago(30d)
    | where AppDisplayName in (applications)
    | where ResultType == "0"
    )
    on UserPrincipalName
| project UserPrincipalName, AssignedRoles
//Alert when any users who hold a privileged Azure AD role make MFA configuration changes or an admin changes MFA details on a privileged user

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

//Lookup the IdentityInfo table for any users holding a privileged role
let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
//Lookup MFA configuration events for those privileged users
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName in~ ("Admin registered security info", "Admin updated security info", "Admin deleted security info", "User registered security info", "User changed default security info", "User deleted security info")
| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
| where UserPrincipalName in~ (privusers)
| project TimeGenerated, OperationName, UserPrincipalName
//Microsoft Graph query to find idle guest accounts. Change le date as required. Query will find all users with last sign in activity prior to that date.

https://graph.microsoft.com/beta/users?$filter=UserType eq 'Guest'&$filter=signInActivity/lastSignInDateTime le 2021-08-01T00:00:00Z&$select=displayName,UserType,signInActivity
//Visualize legacy auth method (i.e Activesync, IMAP etc) by distinct user count over time

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(90d)
| where ResultType == 0
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize Count=dcount(UserPrincipalName) by ClientAppUsed, bin (TimeGenerated, 1d)
| render timechart with (title="Legacy auth methods by distinct user over time")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 0
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize Count=dcount(AccountUpn) by ClientAppUsed, bin (Timestamp, 1d)
| render timechart
//Detect when an Azure AD service principal signs in from an IP previously not seen

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)
| distinct AppId, IPAddress
| join kind=rightanti
    (
    AADServicePrincipalSignInLogs
    | where TimeGenerated > ago(7d)
    | project TimeGenerated, AppId, IPAddress, ResultType, ServicePrincipalName
    )
    on IPAddress
| where ResultType == "0"
| distinct ServicePrincipalName, AppId, IPAddress
//Calculate the percentage of signins to all your Azure AD apps considered risky. Those requiring single factor authentication, coming from an unknown location and from an unknown device

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| summarize
    ['Total Signins']=count(),
    ['At Risk Signins']=countif(NetworkLocationDetails == '[]' and isempty(DeviceTrustType) and AuthenticationRequirement == "singleFactorAuthentication")
    by AppDisplayName
| extend ['At Risk Percentage']=(todouble(['At Risk Signins']) * 100 / todouble(['Total Signins']))
//Visualize signins to your Azure AD tenant with no controls (known device, known location or MFA) vs those with at least one of those controls

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| summarize
    ['Signins with no controls']=countif(NetworkLocationDetails == '[]' and AuthenticationRequirement == "singleFactorAuthentication" and isempty(DeviceTrustType)),
    ['Signins with one or more controls']=countif(NetworkLocationDetails != '[]' or AuthenticationRequirement == "multiFactorAuthentication" or isnotempty(DeviceTrustType)) by
    bin(TimeGenerated, 1d)
| render timechart with (title="Azure AD signins no controls vs one or more controls")
//Find when an Azure AD group is assigned (either permanent or eligble) to an Azure AD PIM assignment

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName in ("Add eligible member to role in PIM completed (permanent)", "Add member to role in PIM completed (permanent)")
| where TargetResources[2].type == "Group"
| extend GroupName = tostring(TargetResources[2].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| project TimeGenerated, OperationName, Actor, GroupName, ['Azure AD Role Name']
//Create a daily summary of activities completed by your Azure AD privileged users

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let timerange=30d;
IdentityInfo
| where TimeGenerated > ago(21d)
| summarize arg_max(TimeGenerated, *) by AccountUPN
| where isnotempty(AssignedRoles)
| where AssignedRoles != "[]"
| project Actor=AccountUPN
| join kind=inner (
    AuditLogs
    | where TimeGenerated > ago(timerange)
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where isnotempty(Actor)
    )
    on Actor
| summarize AdminActivity = make_list(OperationName) by Actor, startofday(TimeGenerated)
//Detect when a user adds someone to an Azure AD privileged role for the first time

//Data connector required for this query - Azure Active Directory - Audit Logs

//First build a set of known users who have completed this action previously
let knownusers=
    AuditLogs
    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
    | where OperationName == "Add member to role"
    //Exclude role additions made by the Azure AD PIM service
    | where Identity != "MS-PIM"
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | distinct Actor;
//Find events in the last day by users not in the known list
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName == "Add member to role"
| where Identity != "MS-PIM"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Azure AD Role Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend Target = tostring(TargetResources[0].userPrincipalName)
| where Actor !in (knownusers)
| project TimeGenerated, Actor, Target, ['Azure AD Role Name']


//Summarize the percentage of signins covered by MFA for your top 20 most popular Azure AD apps

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
//First create a list of your top 20 apps by finding distinct user count by application over 30 days
let top20apps=
    SigninLogs
    | where TimeGenerated > ago (30d)
    | summarize UserCount=dcount(UserPrincipalName)by AppDisplayName
    | sort by UserCount desc 
    | take 20
    | project AppDisplayName;
//Use that list to calculate the percentage of signins to those apps that are covered by MFA
SigninLogs
| where TimeGenerated > ago (30d)
| where AppDisplayName in (top20apps)
| summarize TotalCount=count(),
    MFACount=countif(AuthenticationRequirement == "multiFactorAuthentication"),
    nonMFACount=countif(AuthenticationRequirement == "singleFactorAuthentication")
    by AppDisplayName
| project
    AppDisplayName,
    TotalCount,
    MFACount,
    nonMFACount,
    MFAPercentage=(todouble(MFACount) * 100 / todouble(TotalCount))
| sort by MFAPercentage asc  

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//First create a list of your top 20 apps by finding distinct user count by application over 30 days
let top20apps=
    AADSignInEventsBeta
    | where Timestamp > ago (30d)
    | where LogonType == @"[""interactiveUser""]"
    | summarize UserCount=dcount(AccountUpn)by Application
    | sort by UserCount desc 
    | take 20
    | project Application;
//Use that list to calculate the percentage of signins to those apps that are covered by MFA
AADSignInEventsBeta
| where Timestamp > ago (30d)
| where LogonType == @"[""interactiveUser""]"
| where Application in (top20apps)
| summarize TotalCount=count(),
    MFACount=countif(AuthenticationRequirement == "multiFactorAuthentication"),
    nonMFACount=countif(AuthenticationRequirement == "singleFactorAuthentication")
    by Application
| project
    Application,
    TotalCount,
    MFACount,
    nonMFACount,
    MFAPercentage=(todouble(MFACount) * 100 / todouble(TotalCount))
| sort by MFAPercentage asc  
//Visualize successful self service password resets and account unlocks over time

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (180d)
| where OperationName in ("Reset password (self-service)", "Unlock user account (self-service)")
| summarize
    ['Password Reset']=countif(OperationName == "Reset password (self-service)" and ResultDescription == "Successfully completed reset."),
    ['Account Unlock']=countif(OperationName == "Unlock user account (self-service)" and ResultDescription == "Success")
    by startofweek(TimeGenerated)
| render timechart
    with (
    ytitle="Count",
    xtitle="Day",
    title="Self Service Password Resets and Account Unlocks over time")
//Detects users who have accessed Azure AD Management interfaces, such as Azure AD PowerShell or Graph Explorer, who have not accessed in the previous timeframe. 

//Data connector required for this query - Azure Active Directory - Signin Logs

//Add additional applications to include them in the same query, i.e Defender for Cloud Apps portal.
//Select a time frame to look back on, i.e find users logging on for the first time today not seen in the prior 60 days
let timeframe = startofday(ago(60d));
let applications = dynamic(["Azure Active Directory PowerShell", "Microsoft Azure PowerShell", "Graph Explorer", "ACOM Azure Website", "Azure Portal", "Azure Advanced Threat Protection"]);
SigninLogs
| where TimeGenerated > timeframe and TimeGenerated < startofday(now())
| where AppDisplayName in (applications)
| project UserPrincipalName, AppDisplayName
| join kind=rightanti
    (
    SigninLogs
    | where TimeGenerated > startofday(now())
    | where AppDisplayName in (applications)
    )
    on UserPrincipalName, AppDisplayName
| where ResultType == 0
| project TimeGenerated, UserPrincipalName, ResultType, AppDisplayName, IPAddress, Location, UserAgent
//Visualize the difference been total and distinct user sign ins to an app per day

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(90d)
| where AppDisplayName == "Office 365 Exchange Online"
| where ResultType == 0
| summarize ['Total Signins']=count(), ['Distinct user signins']=dcount(UserPrincipalName) by bin(TimeGenerated, 1d)
| render timechart
    with (
    title="Total vs Distinct signins to Exchange Online",
    xtitle="Day",
    ytitle="Count")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(90d)
| where Application == "Office 365 Exchange Online"
| where ErrorCode == 0
| summarize ['Total Signins']=count(), ['Distinct user signins']=dcount(AccountUpn) by bin(Timestamp, 1d)
| render timechart
//Detect changes to Azure AD Conditional Access policies on weekends or outside of business hours

//Data connector required for this query - Azure Active Directory - Audit Logs

let Saturday = time(6.00:00:00);
let Sunday = time(0.00:00:00);
AuditLogs
| where OperationName has "conditional access"
// extend LocalTime to your time zone
| extend LocalTime=TimeGenerated + 5h
// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am
| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)
| extend ['Conditional Access Policy Name'] = tostring(TargetResources[0].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project LocalTime, 
    OperationName, 
    ['Conditional Access Policy Name'], 
    Actor
| sort by LocalTime desc 
//When Azure AD Identity Protection flags an IP Address as malicious, find any successful or failed logon events in your tenant from that IP

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)

//First create a list of success and erorr codes in Azure AD
let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
//Find the suspicious IP information from the SecurityAlert table, this example looks back 7 days as this is an offline detection
let suspiciousip=
    SecurityAlert
    | where TimeGenerated > ago (7d)
    | where AlertName == "Malicious IP address"
    | extend IPAddress = tostring(parse_json(ExtendedProperties).["Client IP Address"])
    | distinct IPAddress;
//Look back 21 days for any other sign in data from that IP address
SigninLogs
| where TimeGenerated > ago(14d)
| where IPAddress in (suspiciousip)
| where ResultType in(successCodes) or ResultType in(failureCodes)
//Create a summary showing successful and failed logons from that IP address and which users are affected
| summarize
    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),
    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),
    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),
    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),
    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),
    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))
    by IPAddress
//Find which users are failing the most Conditional Access policies, retrieve the total failure count, distinct policy count and the names of the failed policies

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| project TimeGenerated, ConditionalAccessPolicies, UserPrincipalName
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend CAPolicyName = tostring(ConditionalAccessPolicies.displayName)
| where CAResult == "failure"
| summarize
    ['Total Conditional Access Failures']=count(),
    ['Distinct Policy Failure Count']=dcount(CAPolicyName),
    ['Policy Names']=make_set(CAPolicyName)
    by UserPrincipalName
| sort by ['Distinct Policy Failure Count'] desc 
//Summarize the domain names, the count of users and list of users for each guest tenant connecting to your Azure AD tenant

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| project
    TimeGenerated,
    UserPrincipalName,
    HomeTenantId,
    AADTenantId,
    Id,
    ResourceTenantId,
    ResourceIdentity,
    UserId,
    AppDisplayName
| where UserId != "00000000-0000-0000-0000-000000000000"
| where ResourceIdentity != ''
| where HomeTenantId != ''
| where HomeTenantId != AADTenantId
| extend GuestDomain = split(UserPrincipalName, '@')[-1]
| summarize
    ['Guest Domain Names']=make_set(GuestDomain),
    ['Distinct User Count']=dcount(UserPrincipalName),
    ['List of Guest Users']=make_set(UserPrincipalName)
    by HomeTenantId, AppDisplayName
| sort by ['Distinct User Count'] desc 

//Calculate the percentage for all your Azure AD users considered risky. Those requiring single factor authentication, coming from an unknown location and from an unknown device

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
//Include only member accounts if you want to ignore guest signins
| where UserType == "Member"
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| summarize
    ['Total Signins']=count(),
    ['At Risk Signins']=countif(NetworkLocationDetails == '[]' and isempty(DeviceTrustType) and AuthenticationRequirement == "singleFactorAuthentication")
    by UserPrincipalName
| extend ['At Risk Percentage']=(todouble(['At Risk Signins']) * 100 / todouble(['Total Signins']))
| sort by ['At Risk Percentage'] desc 
//Alert when Azure AD guest accounts are denied access (either by Conditional Access or because they aren't granted specific access) to multiple applications in a short time period
//This query uses 3 or more applications within an hour

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago (7d)
| where UserType == "Guest"
| where ResultType in ("53003", "50105")
| summarize
    ['Application Count']=dcount(AppDisplayName),
    ['Application List']=make_set(AppDisplayName)
    by UserPrincipalName, bin(TimeGenerated, 1h)
| where ['Application Count'] >= 3

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago (7d)
| where IsGuestUser == 1
| where ErrorCode  in ("53003", "50105")
| summarize
    ['Application Count']=dcount(Application),
    ['Application List']=make_set(Application)
    by AccountUpn, bin(Timestamp, 1h)
| where ['Application Count'] >= 3
//Find any new operations generated in the Azure AD audit table in the last two weeks compared to the last 180 days, you can adjust the time periods 
//e.g. change 180d to 90d and 14d to 7d would find new events in the last week not seen in the 90 prior to that

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (180d) and TimeGenerated < ago(14d)
| distinct OperationName, LoggedByService
| join kind=rightanti(
    AuditLogs
    | where TimeGenerated > ago(14d)
    | summarize TotalCount=count(), FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by OperationName, LoggedByService
    )
    on OperationName, LoggedByService

// Find users who are assigned a privileged role in Azure AD but haven't activated a role in the last 45 days

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

IdentityInfo
| where TimeGenerated > ago(21d)
| where isnotempty(AssignedRoles)
| where AssignedRoles != "[]"
| summarize arg_max(TimeGenerated, *) by AccountUPN
| join kind=leftanti  (
    AuditLogs
    | where TimeGenerated > ago(45d)
    | where OperationName == "Add member to role completed (PIM activation)"
    | extend AccountUPN = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | summarize arg_max(TimeGenerated, *) by AccountUPN)
    on AccountUPN
//Detect when MFA details for a user are changed, deleted or registered from an IP address that user has never signed in successfully from

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - Audit Logs

//Cache all successful sign in data for users using materialize operator
let signindata=materialize (
    SigninLogs
    | where TimeGenerated > ago(180d)
    | where ResultType == 0
    | distinct UserPrincipalName, UserId, IPAddress);
//Search for audit events showing MFA registrations, deletions or changes in the last day
AuditLogs
| where TimeGenerated > ago(10d)
| where OperationName in ("User registered security info", "User deleted security info", "User registered all required security info")
| where Result == "success"
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend UserId = tostring(TargetResources[0].id)
| project UserPrincipalName, UserId, IPAddress, OperationName
//Join those events back to our summarized sign in data looking for users who register MFA from an IP they have never signed in from
| where isnotempty(IPAddress)
| join kind=leftanti (signindata) on IPAddress, UserId
| distinct UserPrincipalName, IPAddress, OperationName
//Visualize the most popular domains that have redeemed invites to your Azure AD tenant over the last 30 days.

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(30d)
| where OperationName == "Redeem external user invite"
| extend GuestEmail = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['User Domain'] = tostring(split(GuestEmail, "@")[1])
| where isnotempty(['User Domain'])
| summarize Count=count()by ['User Domain']
| sort by Count desc 
| render barchart
//Find new applications your users are signing into in the last month vs the previous 6 months. For each find the first time the app was used, how many total signins and distinct users accessing each one

//Data connector required for this query - Azure Active Directory - Signin Logs

let knownapps=
    SigninLogs
    | where TimeGenerated > ago(180d) and TimeGenerated < ago (30d)
    | distinct AppId;
SigninLogs
| where TimeGenerated > ago(30d)
| where AppId !in (knownapps)
| where isnotempty(AppDisplayName)
| summarize
    ['First Time Seen']=min(TimeGenerated),
    Count=count(),
    ['User Count']=dcount(UserPrincipalName)
    by AppDisplayName
| sort by Count desc 
//Find users who have not elevated any roles in Azure AD PIM in 30 days

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (365d)
| project TimeGenerated, OperationName, Result, TargetResources, InitiatedBy
| where OperationName == "Add member to role completed (PIM activation)"
| where Result == "success"
| extend ['Last Role Activated'] = tostring(TargetResources[0].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| summarize arg_max(TimeGenerated, *) by Actor
| project
    Actor,
    ['Last Role Activated'],
    ['Last Activation Time']=TimeGenerated,
    ['Days Since Last Activation']=datetime_diff("day", now(), TimeGenerated)
| where ['Days Since Last Activation'] >= 30
| sort by ['Days Since Last Activation'] desc
//Find sign ins that have triggered multiple unique conditional access policy successes - maybe a chance to rationalize policy

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| mv-apply ca=todynamic(ConditionalAccessPolicies) on (
    where ca.result == "success"
    | extend PolicyName = tostring(ca.displayName)
    )
| summarize
    ['Count of Poicies Applied']=dcount(PolicyName),
    ['List of Policies Applied']=make_set(PolicyName)
    by CorrelationId, UserPrincipalName
| where ['Count of Poicies Applied'] >= 2
// Calculate the percentage of sign ins requiring authentication strengths, MFA and single factor auth to all of your applications

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| summarize
    ['Total Signin Count']=count(),
    ['Total Authentication Strength Count']=countif(AuthenticationRequirementPolicies has 'Authentication Strength(s)' and AuthenticationRequirement == "multiFactorAuthentication"),
    ['Total MFA Count']=countif(AuthenticationRequirementPolicies !has 'Authentication Strength(s)' and AuthenticationRequirement == "multiFactorAuthentication"),
    ['Total non MFA Count']=countif(AuthenticationRequirement == "singleFactorAuthentication")
    by AppDisplayName
| project
    AppDisplayName,
    ['Total Signin Count'],
    ['Total Authentication Strength Count'],
    ['Authentication Strength Percentage']=(todouble(['Total Authentication Strength Count']) * 100 / todouble(['Total Signin Count'])),
    ['Total MFA Count'],
    ['MFA Percentage']=(todouble(['Total MFA Count']) * 100 / todouble(['Total Signin Count'])),
    ['Total non MFA Count'],
    ['Non MFA Percentage']=(todouble(['Total non MFA Count']) * 100 / todouble(['Total Signin Count']))
| sort by ['Total Signin Count'] desc

//Visualize the MFA types used by your users, i.e text message, mobile app notification, verification code

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| where AuthenticationRequirement == "multiFactorAuthentication"
| project AuthenticationDetails
| extend ['MFA Method'] = tostring(parse_json(AuthenticationDetails)[1].authenticationMethod)
| summarize Count=count()by ['MFA Method']
| where ['MFA Method'] != "Previously satisfied" and isnotempty(['MFA Method'])
| sort by Count desc
| render barchart with (title="Types of MFA Methods used")
//Query to find OAuth applications where permissions were added and removed within 10 minutes

//Data connector required for this query - Azure Active Directory - Audit Logs

let PermissionAddedAlert=
    AuditLogs
    | where OperationName has "Add app role assignment to service principal"
    | extend UserWhoAdded = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend PermissionAdded = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend AppId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[5].newValue)))
    | extend TimeAdded = TimeGenerated
    | project UserWhoAdded, PermissionAdded, AppId, TimeAdded;
let PermissionRemovedAlert=
    AuditLogs
    | where OperationName has "Remove app role assignment from service principal"
    | extend UserWhoRemoved = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend PermissionRemoved = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))
    | extend AppId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[5].newValue)))
    | extend TimeRemoved = TimeGenerated
    | project UserWhoRemoved, PermissionRemoved, AppId, TimeRemoved;
PermissionAddedAlert
| join kind=inner PermissionRemovedAlert on AppId
| where abs(datetime_diff('minute', TimeAdded, TimeRemoved)) <= 10
| extend TimeDiff = TimeAdded - TimeRemoved
| project
    TimeAdded,
    UserWhoAdded,
    PermissionAdded,
    AppId,
    TimeRemoved,
    UserWhoRemoved,
    PermissionRemoved,
    TimeDiff
//This query will hunt for real time risk events flagged as medium or high that aren't confirmed safe by Microsoft and then enrich that data with information from the IdentityInfo table

//Data connector required for this query - Azure Active Directory - AAD User Risk Events
//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let id=
    IdentityInfo
    | summarize arg_max(TimeGenerated, *) by AccountUPN;
let signin=
    SigninLogs
    | where TimeGenerated > ago (14d)
    | where RiskLevelDuringSignIn in ('high', 'medium')
    | join kind=inner id on $left.UserPrincipalName == $right.AccountUPN
    | extend SigninTime = TimeGenerated
    | where RiskEventTypes_V2 != "[]";
AADUserRiskEvents
| where TimeGenerated > ago (14d)
| extend RiskTime = TimeGenerated
| where DetectionTimingType == "realtime"
| where RiskDetail !has "aiConfirmedSigninSafe"
| join kind=inner signin on CorrelationId
| extend TimeDelta = abs(SigninTime - RiskTime)
| project
    SigninTime,
    UserPrincipalName,
    RiskTime,
    TimeDelta,
    RiskEventTypes,
    RiskLevelDuringSignIn,
    City,
    Country,
    EmployeeId,
    AssignedRoles
//Find Azure AD service principals that have only signed in from a single IP address in the last month. You should apply Conditional Access for workloads on them - https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/workload-identity

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

//Microsoft Sentinel query
//First create a distinct count of IP addresses for each AppId and return any AppId with only 1 distinct IP
let appid=
    AADServicePrincipalSignInLogs
    | where TimeGenerated > ago (30d)
    | where ResultType == 0
    | summarize dcount(IPAddress) by AppId
    | where dcount_IPAddress == 1
    | distinct AppId;
//Query the same data for only those AppIds and summarize each IP by the AppId and friendly service principal names
AADServicePrincipalSignInLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where AppId in (appid)
| summarize ['Application Ids']=make_set(AppId) by IPAddress, ServicePrincipalName

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//First create a distinct count of IP addresses for each AppId and return any AppId with only 1 distinct IP
let appid=
    AADSpnSignInEventsBeta
    | where Timestamp > ago (30d)
    | where ErrorCode == 0
    | where IsManagedIdentity == 0
    | summarize dcount(IPAddress) by ApplicationId
    | where dcount_IPAddress == 1
    | distinct ApplicationId;
//Query the same data for only those AppIds and summarize each IP by the AppId and friendly service principal names
AADSpnSignInEventsBeta
| where Timestamp > ago (30d)
| where ErrorCode == 0
| where ApplicationId in (appid)
| summarize ['Application Ids']=make_set(ApplicationId) by IPAddress, ServicePrincipalName

//Visualize the different risk types (e.g password spray, unlikely travel) per month

//Data connector required for this query - Azure Active Directory - AAD User Risk Events

AADUserRiskEvents
| where TimeGenerated > ago (180d)
| where isnotempty(RiskEventType)
| summarize Count=count()by RiskEventType, startofmonth(TimeGenerated)
| render columnchart with (kind=unstacked, title="Risk event types per month", xtitle="Month")
//Find Azure AD Service Principals that have not successfully signed on for the last 30 days

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| where TimeGenerated > ago(180d)
| where ResultType == 0
| summarize arg_max(TimeGenerated, *) by AppId
| project
    ['Last Successful Logon']=TimeGenerated,
    ServicePrincipalName,
    ServicePrincipalId,
    AppId
| join kind = leftanti (
    AADServicePrincipalSignInLogs
    | where TimeGenerated > ago(30d)
    | where ResultType == 0
    | summarize arg_max(TimeGenerated, *) by AppId
    )
    on AppId
| extend ['Days Since Last Logon']=datetime_diff("day", now(), ['Last Successful Logon'])
| project-reorder ['Days Since Last Logon'], ['Last Successful Logon'], ServicePrincipalName, AppId, ServicePrincipalId
| sort by ['Last Successful Logon'] desc    
//Detects when a BitLocker key is read in Azure AD and retrieves the device and key ids

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Read BitLocker key"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend s = tostring(AdditionalDetails[0].value)
| parse s with * "ID: '" KeyId "'" *
| parse s with * "device: '" DeviceId "'"
| project TimeGenerated, OperationName, Actor, KeyId, DeviceId
//Detect when a user flags 3 or more distinct Azure AD risk events within a single day

//Data connector required for this query - Azure Active Directory - AAD User Risk Events

AADUserRiskEvents
| where TimeGenerated > ago(7d)
| where RiskState != "dismissed"
| summarize
    ['Distinct count of risk events']=dcount(RiskEventType),
    ['List of risk events']=make_set(RiskEventType)
    by UserPrincipalName, bin(TimeGenerated, 1d)
| where ['Distinct count of risk events'] >= 3
//Detect a successful self service password reset or account unlock from an IP address that user hasn't successfully signed into from in the last 30 days

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Azure Active Directory - Signin Logs

//Find successful password reset and account unlocks in the last day
AuditLogs
| where TimeGenerated > ago (1d)
| where OperationName == "Unlock user account (self-service)" and ResultDescription == "Success" or OperationName == "Reset password (self-service)" and ResultDescription == "Successfully completed reset."
| extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project
    ['Reset Unlock or Time']=TimeGenerated,
    OperationName,
    UserPrincipalName,
    IPAddress
//Take the UserPrincipalName of the event and the IP address, join back to sign on logs to find events where the IP address has not been seen from that user
| join kind=leftanti 
    (
    SigninLogs
    | where TimeGenerated > ago(30d)
    | where ResultType == 0
    )
    on UserPrincipalName, IPAddress
//Summarize all groups that have had users added to them via dynamic rules

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName == "Add member to group"
| where Identity == "Microsoft Approval Management"
| where TargetResources[0].type == "User"
| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend User = tostring(TargetResources[0].userPrincipalName)
| summarize ['Count of Users Added']=dcount(User), ['List of Users Added']=make_set(User) by GroupName
| sort by GroupName asc  

//Find any Azure AD service principals that have been granted any .All access in the last year that haven't signed in for 30 days. May include already deleted service principals.

//Data connector required for this query - Azure Active Directory - Audit Logs

let delegatedaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add delegated permission grant"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | extend ['Permission type'] = strcat("Delegated")
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
    | project
        TimeGenerated,
        ['Permission type'],
        ['Permissions granted'],
        ServicePrincipalId;
let appaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add app role assignment to service principal"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ['Permission type'] = strcat("Application")
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
    | project
        TimeGenerated,
        ServicePrincipalId,
        ['Permission type'],
        ['Permissions granted'];
union delegatedaccess, appaccess
| where ['Permissions granted'] contains ".All"
| distinct ServicePrincipalId
| join kind=leftanti (
    AADServicePrincipalSignInLogs
    | where TimeGenerated > ago (30d)
    | where ResultType == "0"
    | distinct ServicePrincipalName, ServicePrincipalId)
    on ServicePrincipalId



//Detects users who add a service principal to Azure AD for the first time.

//Data connector required for this query - Azure Active Directory - Audit Logs

let knownusers=
    AuditLogs
    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
    | where OperationName == "Add service principal"
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where isnotempty(Actor)
    | distinct Actor;
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName == "Add service principal"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where isnotempty(Actor)
| where Actor !in (knownusers)
| extend AppId = tostring(AdditionalDetails[1].value)
| project TimeGenerated, Actor, AppId
//Find the guests in your tenant connecting to the most applications. They are the biggest risk and the best target for additional controls like Conditional Access.

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where UserType == "Guest"
//Exclude the Microsoft apps for guest account management
| where AppDisplayName !in ("My Apps", "Microsoft App Access Panel", "My Access", "My Profile", "Microsoft Invitation Acceptance Portal")
| summarize
    ['Count of Applications']=dcount(AppDisplayName),
    ['List of Application']=make_set(AppDisplayName)
    by UserPrincipalName
| sort by ['Count of Applications'] desc 

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 0
| where IsGuestUser == 1
//Exclude the Microsoft apps for guest account management
| where Application  !in ("My Apps", "Microsoft App Access Panel", "My Access", "My Profile", "Microsoft Invitation Acceptance Portal")
| summarize
    ['Count of Applications']=dcount(Application),
    ['List of Application']=make_set(Application)
    by AccountUpn
| sort by ['Count of Applications'] desc 
//Create a summary of which resources each of your service principals are connecting to. The higher the count the potential higher blast radius.

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| where TimeGenerated > ago(30d)
| where ResultType == "0"
| summarize
    ['List of Azure Resources']=make_set(ResourceDisplayName),
    ['Count of Azure Resources']=dcount(ResourceDisplayName)
    by ServicePrincipalName
| sort by ['Count of Azure Resources'] desc
//Detect the first time a service principal fails Conditional Access

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

//Microsoft Sentinel query
//First find service principals that have previously failed
let knownfailures=
    AADServicePrincipalSignInLogs
    | where TimeGenerated > ago(30d) and TimeGenerated < ago (1d)
    | where ResultType == "53003"
    | distinct AppId;
//Find any new failures in the last day
AADServicePrincipalSignInLogs
| where TimeGenerated > ago(1d)
| where ResultType == "53003"
| where AppId !in (knownfailures)
| project
    TimeGenerated,
    ServicePrincipalName,
    ServicePrincipalId,
    AppId,
    ConditionalAccessPolicies,
    IPAddress

//Detect the first time a service principal fails Conditional Access

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//Advanced Hunting query
let knownfailures=
    AADSpnSignInEventsBeta
    | where Timestamp > ago(30d) and Timestamp < ago (1d)
    | where ErrorCode == "53003"
    | distinct ApplicationId;
AADSpnSignInEventsBeta
| where Timestamp > ago(1d)
| where ErrorCode == "53003"
| where ApplicationId  !in (knownfailures)
| project
    Timestamp,
    ServicePrincipalName,
    ServicePrincipalId,
    ApplicationId,
    IPAddress
//Visualize sign in attempts to your Azure AD tenant by device trust type

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| extend ['Trust Type']=case(isnotempty(DeviceTrustType), strcat=DeviceTrustType,
    isempty(DeviceTrustType), strcat="Untrusted",
    "unknown")
| summarize Count=count()by ['Trust Type'], bin(TimeGenerated, 1d)
| render timechart with (title="Signins to Azure AD by trust type")
//Query to find high or medium real time risk events for users who have an assigned Azure AD role

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - AAD User Risk Events
//Data connector required for this query - Microsoft Sentinel UEBA

let id=
    IdentityInfo
    | summarize arg_max(TimeGenerated, *) by AccountUPN;
let signin=
    SigninLogs
    | where TimeGenerated > ago (14d)
    | where RiskLevelDuringSignIn in ('high', 'medium')
    | join kind=inner id on $left.UserPrincipalName == $right.AccountUPN
    | extend SigninTime = TimeGenerated
    | where RiskEventTypes_V2 != "[]";
AADUserRiskEvents
| where TimeGenerated > ago (14d)
| extend RiskTime = TimeGenerated
| where DetectionTimingType == "realtime"
| where RiskDetail !has "aiConfirmedSigninSafe"
| join kind=inner signin on CorrelationId
| where AssignedRoles != "[]"
| extend TimeDelta = abs(SigninTime - RiskTime)
| project
    SigninTime,
    UserPrincipalName,
    RiskTime,
    TimeDelta,
    RiskEventTypes,
    RiskLevelDuringSignIn,
    City,
    Country,
    EmployeeId,
    AssignedRoles
//Create a pivot table showing all the actions taken by your privileged users

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

//Lookup the IdentityInfo table for any users holding a privileged role
let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
//Search for all actions taken by those users in the last 7 days
AuditLogs
| where TimeGenerated > ago(7d)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where Actor in (privusers)
//Create a pivot table counting each action for each user
| evaluate pivot(OperationName, count(), Actor)
| order by Actor asc 
// Detects when a service principal has been added to an Azure AD role

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Add member to role"
| where TargetResources[0].type == "ServicePrincipal"
| extend ['Service Principal Object Id'] = tostring(TargetResources[0].id)
| extend ['Application Display Name'] = tostring(TargetResources[0].displayName) 
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Azure AD Role Added'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| project TimeGenerated, Actor, ['Azure AD Role Added'], ['Service Principal Object Id'], ['Application Display Name']
//Find any CA policies that are not actively in use (no success or failure events)

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(180d)
| where UserType == "Member"
| mv-expand todynamic(ConditionalAccessPolicies)
| extend CAResult=tostring(ConditionalAccessPolicies.result), CAName=tostring(ConditionalAccessPolicies.displayName)
| summarize TotalCount=count(),ResultSet=make_set(CAResult) by CAName
| where not(ResultSet has_any ("success","failure"))
| sort by CAName asc 

//Find Azure AD conditional access policies that have no hits for 'success' or 'failure' over the last month

//Data connector required for this query - Azure Active Directory - Signin Logs

//Check that these policies are configured correctly or still required
SigninLogs
| where TimeGenerated > ago (30d)
| project TimeGenerated, ConditionalAccessPolicies
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend ['Conditional Access Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| summarize ['Conditional Access Result']=make_set(CAResult) by ['Conditional Access Policy Name']
| where ['Conditional Access Result'] !has "success"
    and ['Conditional Access Result'] !has "failure"
    and ['Conditional Access Result'] !has "unknownFutureValue"
| sort by ['Conditional Access Policy Name'] asc 
// Detects when a user flags an Azure AD risk event followed by changes to their MFA profile - potentially detecting a bad actor changing MFA details

//Data connector required for this query - Azure Active Directory - AAD User Risk Events
//Data connector required for this query - Azure Active Directory - Audit Logs

// Timeframe = the minutes between flagging a risk event and MFA details being changed
let timeframe = 120;
//Search for real time risk events only and retrieve Correlation Id
AADUserRiskEvents
| where TimeGenerated > ago (1d)
| where DetectionTimingType == "realtime"
| where RiskDetail <> "aiConfirmedSigninSafe"
| project CorrelationId
//Join Correlation Id back to sign in data to retrieve the initial sign in time that was flagged for risk
| join kind=inner(
SigninLogs
| where TimeGenerated > ago (1d))
on CorrelationId
| summarize ['Risky Signin Time']=min(TimeGenerated) by CorrelationId, UserPrincipalName
//Join risky sign in UserPrincipalName to audit log for MFA events
| join kind=inner (
    AuditLogs
    | where TimeGenerated > ago (1d)
    | where OperationName in ("User registered security info", "User deleted security info","User registered all required security info")
    | where Result == "success"
    | extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
//Find the latest event in the MFA registration process
    | summarize arg_max(TimeGenerated, *) by UserPrincipalName
    | project
        ['MFA Change Time']=TimeGenerated,
        OperationName,
        UserPrincipalName)
    on UserPrincipalName
//Calculate the time between the initial sign in event and the MFA change time
| extend ['Minutes Between Events']=datetime_diff("minute",['MFA Change Time'], ['Risky Signin Time'])
| project-away UserPrincipalName1
| project-reorder ['Risky Signin Time'], ['MFA Change Time'], ['Minutes Between Events'], UserPrincipalName, OperationName, CorrelationId
//Find events where the time between the two events was less than 120 minutes
| where ['Minutes Between Events'] < timeframe
//Visualize signins from External Azure AD guests (those that belong to another Azure AD tenant) vs External Guests (such as Gmail) to your tenant

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (45d)
| where UserType == "Guest"
| summarize
    ['External Guests']=countif(ResourceTenantId == HomeTenantId),
    ['External Azure AD Guests']=countif(ResourceTenantId != HomeTenantId)
    by bin(TimeGenerated, 1d)
| render timechart with (title="External Azure AD Guests vs External Guests", ytitle="Count")

//Detect when an admin adds a new unverified or verified domain into your Azure AD tenant

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName in ("Add verified domain", "Add unverified domain")
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend Domain = tostring(TargetResources[0].displayName)
| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], Domain
// Detects when a self service password reset has been initiated via MS Graph and is successful

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "POST UserAuthMethod.ResetPasswordOnPasswordMethods"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeGenerated, OperationName, Actor, CorrelationId
| join kind=inner
    (AuditLogs
    | where OperationName == "Reset password (by admin)"
    | extend Target = tostring(TargetResources[0].userPrincipalName)
    | where Result == "success"
    )
    on CorrelationId
| project GraphPostTime=TimeGenerated, PasswordResetTime=TimeGenerated1, Actor, Target
//Summarize and visualize the roles being activated in Azure AD PIM

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(30d)
| where OperationName == "Add member to role completed (PIM activation)"
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| summarize Count=count()by ['Azure AD Role Name']
| sort by Count
| render barchart with (title="Count of Azure AD PIM activations by role")
//Create a pivot table showing all your users who have signed in with legacy auth, which applications they are using (such as IMAP or ActiveSync) and the count of each

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
| where isnotempty(ClientAppUsed)
| evaluate pivot(ClientAppUsed, count(), UserPrincipalName)

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 0
| where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
| where isnotempty(ClientAppUsed)
| evaluate pivot(ClientAppUsed, count(), AccountUpn)
//Find users that have connected successfully via legacy auth for the first time
//First find users with existing successful legacy auth connections

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
let knownusers=
    SigninLogs
    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
    | where ResultType == 0
    | where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
    | distinct UserPrincipalName;
//Find any new connections in the last day from users not in the existing list
SigninLogs
| where TimeGenerated > ago(1d)
| where ResultType == 0
| where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
| where isnotempty(ClientAppUsed)
| where UserPrincipalName !in (knownusers)
| distinct UserPrincipalName, AppDisplayName, ClientAppUsed, IPAddress

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//First find users with existing successful legacy auth connections. Advanced Hunting only stores 30 days of data, but otherwise the same query works
let knownusers=
    AADSignInEventsBeta
    | where Timestamp > ago(30d) and Timestamp < ago(1d)
    | where LogonType == @"[""interactiveUser""]"
    | where ErrorCode == 0
    | where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
    | where isnotempty(ClientAppUsed)
    | distinct AccountUpn;
//Find any new connections in the last day from users not in the existing list
AADSignInEventsBeta
| where Timestamp > ago(1d)
| where LogonType == @"[""interactiveUser""]"
| where ErrorCode == 0
| where ClientAppUsed !in ("Mobile Apps and Desktop clients", "Browser")
| where isnotempty(ClientAppUsed)
| where AccountUpn !in (knownusers)
| distinct AccountUpn, Application, ClientAppUsed, IPAddress


//Detect when a user is added and removed from an Azure AD role within a short time frame

//Data connector required for this query - Azure Active Directory - Audit Logs

//Timerange = the amount of data to look back on, timeframe = the time between the role being added and removed
let timerange=7d;
let timeframe=4h;
AuditLogs
| where TimeGenerated > ago (timerange)
| where OperationName == "Add member to role"
| where Result == "success"
//Exclude role additions from Azure AD PIM
| where Identity <> "MS-PIM"
| extend User = tostring(TargetResources[0].userPrincipalName)
| extend Role = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend UserWhoAdded = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeAdded=TimeGenerated, User, Role, UserWhoAdded
| join kind=inner (
    AuditLogs
    | where TimeGenerated > ago (timerange)
    | where OperationName == "Remove member from role"
    //Exclude role removals from Azure AD PIM
    | where Result == "success"
    | where Identity <> "MS-PIM"
    | extend User = tostring(TargetResources[0].userPrincipalName)
    | extend Role = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].oldValue)))
    | extend UserWhoRemoved = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | project TimeRemoved=TimeGenerated, User, Role, UserWhoRemoved
    )
    on User, Role
| extend ['Time User Held Role'] = TimeRemoved - TimeAdded
| where ['Time User Held Role'] < ['timeframe']
| project
    TimeAdded,
    TimeRemoved,
    ['Time User Held Role'],
    User,
    Role,
    UserWhoAdded,
    UserWhoRemoved

//Detect when a domain is added or removed to either the allow or block list in Azure AD external identities

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Update policy"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| mv-expand TargetResources
| extend modifiedProperties = parse_json(TargetResources).modifiedProperties
| mv-expand modifiedProperties  
| extend newValue = parse_json(modifiedProperties).newValue
| mv-expand todynamic(newValue)
| where newValue has "InvitationsAllowedAndBlockedDomainsPolicy"
| project TimeGenerated, OperationName, Actor, ['New Domain Policy']=newValue

//Alert on successful self service password resets at suspicious times

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
// extend LocalTime to your time zone
| extend LocalTime=TimeGenerated + 5h
| where LocalTime > ago(7d)
| where OperationName == "Reset password (self-service)"
| where ResultDescription == "Successfully completed reset."
// Change hours of the day to suit your company, i.e this would find self service password reset events between 11pm and 4am
| where hourofday(LocalTime) !between (4 .. 23)
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['IP Address of User'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project LocalTime, OperationName, ResultDescription, User, ['IP Address of User']
//Summarize the permissions granted to your Azure AD apps over the last year

//Data connector required for this query - Azure Active Directory - Audit Logs

//Find applications that have been deleted
let deletedapps=
AuditLogs
| where OperationName == "Remove service principal"
| extend ServicePrincipalId = tostring(TargetResources[0].id)
| project ServicePrincipalId;
let delegatedaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add delegated permission grant"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | extend ['Permission type'] = strcat("Delegated")
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
//Exclude deleted applications
    | where ServicePrincipalId !in (deletedapps)
    | project
        TimeGenerated,
        ['Permission type'],
        ['Permissions granted'],
        ServicePrincipalId;
let appaccess=
    AuditLogs
    | where TimeGenerated > ago(365d)
    | where OperationName has "Add app role assignment to service principal"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend ['Permission type'] = strcat("Application")
    | extend ServicePrincipalId = tostring(TargetResources[1].id)
    | summarize arg_max(TimeGenerated, *) by ServicePrincipalId
//Exclude deleted applications
    | where ServicePrincipalId !in (deletedapps)
    | project
        TimeGenerated,
        ServicePrincipalId,
        ['Permission type'],
        ['Permissions granted'];
union delegatedaccess, appaccess
| mv-expand ['Permissions granted']
| where isnotempty( ['Permissions granted'])
//Extend new permission field
| extend Permission = strcat(['Permission type']," - ",['Permissions granted'])
| summarize PermissionCount=count()by Permission
| sort by PermissionCount desc 
//Summarize which conditional access policies your inbound guests have logged any successes or failures against.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (90d)
| where UserType == "Guest"
| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
| project ConditionalAccessPolicies, UserPrincipalName, HomeTenantId
| project-rename GuestTenantId=HomeTenantId
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend CAName = tostring(ConditionalAccessPolicies.displayName)
| where CAResult has_any ("success", "failure")
| extend ['Conditional Access Result']=strcat(CAName, " || ", CAResult)
| summarize
    ['Conditional Access Outcomes']=make_set(['Conditional Access Result'])
    by
    GuestTenantId
| order by GuestTenantId asc
//Alert when a user successfully signs in from both a new location and using a new MFA method

//Data connector required for this query - Azure Active Directory - Signin Logs

//Cache all authentication methods and locations to memory using the materialize function for the last 6 months
let mfahistory = materialize  (
    SigninLogs
    | where TimeGenerated > ago (180d) and TimeGenerated < ago(1d)
    | where ResultType == 0
    | where AuthenticationRequirement == "multiFactorAuthentication"
    | extend AuthMethod = tostring(MfaDetail.authMethod)
    | where isnotempty(AuthMethod)
    | distinct UserPrincipalName, AuthMethod, Location);
//Find sign ins from the last day that have both a new location and MFA method
mfahistory
| join kind=rightanti  (
    SigninLogs
    | where TimeGenerated > ago (1d)
    | where ResultType == 0
    | where AuthenticationRequirement == "multiFactorAuthentication"
    | extend AuthMethod = tostring(MfaDetail.authMethod)
    | where isnotempty(AuthMethod)
    | distinct 
        UserPrincipalName,
        AuthMethod,
        AppDisplayName,
        Location,
        IPAddress)
    on UserPrincipalName, Location
//Adds a friendly error description to the AADServicePrincipalSignInLogs table for any non successful signins

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| where ResultType != "0"
| extend ErrorDescription = case (
    ResultType == "7000215", strcat("Invalid client secret is provided"),
    ResultType == "7000222", strcat("The provided client secret keys are expired"),
    ResultType == "700027", strcat("Client assertion failed signature validation"),
    ResultType == "700024", strcat("Client assertion is not within its valid time range"),
    ResultType == "70021", strcat("No matching federated identity record found for presented assertion"),
    ResultType == "500011", strcat("The resource principal named {name} was not found in the tenant named {tenant}"),
    ResultType == "700082", strcat("The refresh token has expired due to inactivity"),
    ResultType == "90025", strcat("Request processing has exceeded gateway allowance"),
    ResultType == "500341", strcat("The user account {identifier} has been deleted from the {tenant} directory"),
    ResultType == "100007", strcat("AAD Regional ONLY supports auth either for MSIs OR for requests from MSAL using SN+I for 1P apps or 3P apps in Microsoft infrastructure tenants"),
    ResultType == "1100000", strcat("Non-retryable error has occurred"),
    ResultType == "90033", strcat("A transient error has occurred. Please try again"),
    ResultType == "53003", strcat("Access has been blocked by Conditional Access policies. The access policy does not allow token issuance."),
    "Unknown"
    )
| project
    TimeGenerated,
    ServicePrincipalName,
    ServicePrincipalId,
    ErrorDescription,
    ResultType,
    IPAddress
//Find Azure AD applications that have had no signins for over 30 days. May be a sign of an app no longer in use or users bypassing SSO.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (365d)
| where ResultType == 0
| summarize arg_max(TimeGenerated, *) by AppId
| project
    AppDisplayName,
    ['Last Logon Time']=TimeGenerated,
    ['Days Since Last Logon']=datetime_diff("day", now(), TimeGenerated)
| where ['Days Since Last Logon'] > 30
//Visualize the standard deviation of MFA failures per day using toscalar()

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query

let AverageMFAFailures = toscalar(SigninLogs
| where TimeGenerated > ago(60d)
| where ResultType == 500121
| summarize Count=count() by bin(TimeGenerated, 1d)
| summarize avg(Count));
SigninLogs
| where TimeGenerated > ago(60d)
| where ResultType == 500121
| summarize Count=count() by bin(TimeGenerated, 1d)
| extend Deviation = (Count - AverageMFAFailures) / AverageMFAFailures
| project-away Count
//Visualize the deviation per day
| render columnchart with (title="Deviation of MFA failures per day")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

let AverageMFAFailures = toscalar(AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 500121
| summarize Count=count() by bin(Timestamp, 1d)
| summarize avg(Count));
AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 500121
| summarize Count=count() by bin(Timestamp, 1d)
| extend Deviation = (Count - AverageMFAFailures) / AverageMFAFailures
| project-away Count
//Visualize the deviation per day
| render columnchart with (title="Deviation of MFA failures per day")
//Detect when a group is added to Azure AD with the 'Azure AD roles can be assigned to this group' flag enabled

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(90d)
| where OperationName == "Add group"
| where parse_json(tostring(TargetResources[0].modifiedProperties))[1].displayName == "IsAssignableToRole"
| where parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue))[0] == true
| extend GroupName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))[0])
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project TimeGenerated, OperationName, GroupName, Actor, ['Actor IP Address']

//Detect when an Azure AD guest account is assigned to an Azure AD PIM role

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (1d)
| where OperationName in ("Add eligible member to role in PIM completed (permanent)", "Add eligible member to role in PIM completed (timebound)", "Add member to role in PIM completed (permanent)", "Add member to role in PIM completed (timebound)")
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| extend Target = tostring(TargetResources[2].userPrincipalName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where Target contains "#ext#"
| project TimeGenerated, OperationName, Actor, Target, ['Azure AD Role Name']
//Lists guests who have been invited but not yet redeemed their invites.

//Data connector required for this query - Azure Active Directory - Audit Logs

//Excludes newly invited guests (last 30 days).
let timerange=365d;
let timeframe=30d;
AuditLogs
| where TimeGenerated between (ago(timerange) .. ago(timeframe)) 
| where OperationName == "Invite external user"
| extend GuestUPN = tolower(tostring(TargetResources[0].userPrincipalName))
| project TimeGenerated, GuestUPN
| join kind=leftanti  (
    AuditLogs
    | where TimeGenerated > ago (timerange)
    | where OperationName == "Redeem external user invite"
    | where CorrelationId <> "00000000-0000-0000-0000-000000000000"
    | extend d = tolower(tostring(TargetResources[0].displayName))
    | parse d with * "upn: " GuestUPN "," *
    | project TimeGenerated, GuestUPN)
    on GuestUPN
| distinct GuestUPN
//Detect when a successful self service password (SSPR) event is followed by a medium or high risk sign in within 2 hours
//Threat actors are known to socially engineer helpdesk staff to update MFA methods to allow them to complete SSPR

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - Audit Logs

//Looks back 7 days by default for events within 2 hours of each other, but you can update to suit

let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
AuditLogs
| where TimeGenerated > ago(7d)
| where OperationName == "Reset password (self-service)"
| where ResultDescription == "Successfully completed reset."
| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
| project-rename PasswordResetTime=TimeGenerated
| project UserPrincipalName, PasswordResetTime, OperationName
| join kind=inner(
SigninLogs
    | where TimeGenerated > ago(7d)
    | where ResultType in (successCodes)
    | where RiskLevelDuringSignIn in ("high", "medium")
    | project
        RiskTime=TimeGenerated,
        UserPrincipalName,
        ResultType,
        ResultDescription,
        AppDisplayName,
        IPAddress,
        Location,
        UserAgent
    )
    on UserPrincipalName
| extend ['Time Between Events']=datetime_diff('minute', PasswordResetTime, RiskTime)
| project-reorder
    PasswordResetTime,
    RiskTime,
    ['Time Between Events'],
    UserPrincipalName,
    OperationName,
    ResultType,
    ResultDescription,
    AppDisplayName
| where ['Time Between Events'] <= 120
//Adds logic to your SigninLogs to determine whether guest authentications are inbound (guests accessing your tenant) or outbound (your users accessing other tenants)

//Data connector required for this query - Azure Active Directory - Sign in Logs

SigninLogs
| where TimeGenerated > ago (1d)
| where UserType == "Guest"
| project TimeGenerated, UserPrincipalName, AppDisplayName, ResultType, IPAddress, HomeTenantId, ResourceTenantId, AADTenantId
| extend ['Guest Type']=case(AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId, strcat("Inbound Guest"),
                             AADTenantId == HomeTenantId and ResourceTenantId != AADTenantId, strcat("Outbound Guest"),
"unknown")
//Detect when a user who holds an Azure AD privilege role fails MFA multiple times in a short time period. This example uses 2 failures within 20 minutes.

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
SigninLogs
| where TimeGenerated > ago(1d)
| where ResultType == "500121"
| where UserPrincipalName in (privusers)
| mv-expand todynamic(AuthenticationDetails)
| extend ['MFA Failure Type'] = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
| where ['MFA Failure Type'] startswith "MFA denied"
| summarize
    ['MFA Failure Count']=count(),
    ['MFA Failure Reasons']=make_list(['MFA Failure Type'])
    by UserPrincipalName, bin(TimeGenerated, 20m)
| where ['MFA Failure Count'] >= 2
//Query your Azure Active Directory audit logs for any phone numbers that have been registered to multiple users for MFA

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (30d)
| where Result == "success"
| where Identity == "Azure Credential Configuration Endpoint Service"
| where OperationName == "Update user"
| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
| extend PhoneNumber = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue))[0].PhoneNumber)
| where isnotempty(PhoneNumber)
| summarize Users=make_set(UserPrincipalName) by PhoneNumber
| extend CountofUsers=array_length(Users)
| where CountofUsers > 1
//Groups MFA phone registration events into the number that was registered, can be useful to detect threat actors registering multiple accounts to the same numbers for persistence

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(90d)
| where TargetResources has "PhoneNumber"
| where OperationName has "Update user"
| where TargetResources has "StrongAuthenticationMethod"
| extend InitiatedBy = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
| extend targetResources=parse_json(TargetResources)
| mv-apply tr = targetResources on (
    extend targetResource = tr.displayName
    | mv-apply mp = tr.modifiedProperties on (
    where mp.displayName == "StrongAuthenticationUserDetails"
    | extend NewValue = tostring(mp.newValue)
    ))
| project TimeGenerated, NewValue, UserPrincipalName,InitiatedBy
| mv-expand todynamic(NewValue)
| mv-expand NewValue.[0]
| extend AlternativePhoneNumber = tostring(NewValue.AlternativePhoneNumber)
| extend Email = tostring(NewValue.Email)
| extend PhoneNumber = tostring(NewValue.PhoneNumber)
| extend VoiceOnlyPhoneNumber = tostring(NewValue.VoiceOnlyPhoneNumber)
| project TimeGenerated, UserPrincipalName, InitiatedBy,PhoneNumber, AlternativePhoneNumber, VoiceOnlyPhoneNumber, Email
| where isnotempty(PhoneNumber)
| summarize ['Count of Users']=dcount(UserPrincipalName), ['List of Users']=make_set(UserPrincipalName) by PhoneNumber
| sort by ['Count of Users'] desc 
//Visualize distinct users allowed to connect via legacy auth vs blocked by conditional access

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(180d)
| where ResultType in ("0", "53003")
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize
    ['Legacy Auth Users Allowed']=dcountif(UserPrincipalName, ResultType == 0),
    ['Legacy Auth Users Blocked']=dcountif(UserPrincipalName, ResultType == 53003)
    by bin(TimeGenerated, 1d)
| render timechart with (title="Legacy auth distinct users allowed vs blocked by Conditional Access")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//Visualize distinct users allowed to connect via legacy auth vs blocked by conditional access
AADSignInEventsBeta
| where Timestamp > ago(180d)
| where ErrorCode  in ("0", "53003")
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize
    ['Legacy Auth Users Allowed']=dcountif(AccountUpn, ErrorCode == 0),
    ['Legacy Auth Users Blocked']=dcountif(AccountUpn, ErrorCode == 53003)
    by bin(Timestamp, 1d)
| render timechart 
//Detect when a user reports suspicious MFA activity via the updated user risk integration

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where ResultType == 500121
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResultDetail=AuthenticationDetails.authenticationStepResultDetail
| where AuthResultDetail == "SuspiciousActivityReported"
| project TimeGenerated, UserPrincipalName, ResultType, AppDisplayName, AuthResultDetail, Location, IPAddress, UserAgent, CorrelationId

//These events are also written to Azure AD Identity Protection

//Data connector required for this query - Azure Active Directory Identity Protection

AADUserRiskEvents
| where RiskEventType == "userReportedSuspiciousActivity"
| project TimeGenerated, UserPrincipalName, DetectionTimingType, RiskEventType, RiskState

//Query to identity Security Alerts where they were triggered by a new user agent not seen for the previous 7 days. Update known IP Addresses from "1.1.1" to your corporate IP addresses to exclude

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)

let IPs=
    SecurityAlert
    | project
        TimeGenerated,
        Status,
        AlertName,
        CompromisedEntity,
        ExtendedProperties,
        ProviderName
    | where TimeGenerated > ago (1h)
    | where ProviderName in ('MCAS', 'IPC')
    | where AlertName in ('Impossible travel activity', 'Multiple failed login attempts', 'Unfamiliar sign-in properties', 'Anonymous IP address', 'Atypical travel')
    | where Status contains "New"
    | extend Properties = tostring(parse_json(ExtendedProperties))
    | extend UserPrincipalName = CompromisedEntity
    | extend ipv4Addresses = extract_all(@"(([\d]{1,3}\.){3}[\d]{1,3})", dynamic([1]), Properties)
    | extend ipv4Add = translate('["]', '', tostring(ipv4Addresses))
    | extend ipv4Split =split(ipv4Add, ",")
    | mv-expand ipv4Split
    | extend ipv4Split_s = tostring(ipv4Split);
SigninLogs
| project
    TimeGenerated,
    UserPrincipalName,
    IPAddress,
    AppDisplayName,
    ResultType,
    UserAgent,
    Location
| where TimeGenerated > ago(7d)
| where IPAddress !startswith "1.1.1."
| where ResultType == 0 or ResultType == 50158
| join kind=inner IPs on UserPrincipalName, $left.IPAddress == $right.ipv4Split_s
| summarize AgentCount = count()by UserPrincipalName, UserAgent
| where AgentCount == 1
//Visualize the most popular enterprise applications accessed by guest accounts

//Data connector required for this query - Azure Active Directory - Signin Logs

let timeframe=45d;
SigninLogs
| where TimeGenerated > ago(timeframe)
| where UserType == "Guest" or UserPrincipalName contains "#ext#"
| where ResultType == 0
// Exclude Microsoft management applications
| where AppDisplayName !in ("Microsoft Invitation Acceptance Portal", "My Apps", "Microsoft App Access Panel", "Microsoft Authentication Broker")
| summarize AppCount=count()by AppDisplayName
| sort by AppCount desc 
| render piechart with (title="Most Popular Apps Accessed by Guests")
//Create a summary of PIM activations for all your users per week

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (30d)
| where OperationName == "Add member to role completed (PIM activation)"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend Role = tostring(TargetResources[0].displayName)
| where isnotempty(User)
| summarize
    ['Roles Activated']=make_list(Role),
    ['Times Activated']=make_list(TimeGenerated)
    by User, ['Week Starting']=startofweek(TimeGenerated)
| sort by User asc, ['Week Starting'] desc 
//Find the applications with the most signins coming from unknown locations (not defined in Conditional Access) and only requiring single factor authentication

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where NetworkLocationDetails == '[]'
| where AuthenticationRequirement == "singleFactorAuthentication"
| summarize ['Count of signins']=count(), ['Distinct user count']=dcount(UserPrincipalName) by AppDisplayName
| sort by ['Distinct user count'] desc 
//Detect users trying to access multiple applications they haven't been granted access to over a short period of time
//In this example alert when a user attempts to access 2 or more unique applications in 30 minutes

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where ResultType == "50105"
| summarize
    ['Denied Application List']=make_set(AppDisplayName),
    ['Count of Applications']=dcount(AppDisplayName)
    by UserPrincipalName, bin(TimeGenerated, 30m)
| where ['Count of Applications'] >= 2
//Create a pivot table of all non password authentication methods by user. This is useful to migrate users from less secure methods like text message to more secure methods.

//Data connector required for this query - Azure Active Directory - Signin Logs

let isGUID = "[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}";
SigninLogs
| where TimeGenerated > ago(30d)
| mv-expand todynamic(AuthenticationDetails)
| extend ['Authentication Method'] = tostring(AuthenticationDetails.authenticationMethod)
//Exclude previously satisifed, passwords and other data and any UserPrincipalName that comes through as a guid
| where ['Authentication Method'] !in ("Previously satisfied", "Password", "Other")
    and isnotempty(['Authentication Method'])
    and not(UserPrincipalName matches regex isGUID)
//Create pivot table of each method and the count by user
| evaluate pivot(['Authentication Method'], count(), UserPrincipalName)
| sort by UserPrincipalName asc
//Detect when a custom security attribute is set on a user

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Update attribute values assigned to a user"
| extend x = tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].displayName)
| extend ["Attribute Value"] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))[0])
| extend Target = tostring(TargetResources[0].userPrincipalName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| parse x with * '.' ['Attribute Set Name'] "_" *
| extend ["Attribute Name"]=split(x, "_")[1]
| project
    TimeGenerated,
    OperationName,
    Target,
    ['Attribute Set Name'],
    ['Attribute Name'],
    ['Attribute Value'],
    Actor
//Creates a list of your applications and summarizes successful signins by members vs guests separated to total and distinct signins

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| project TimeGenerated, UserType, ResultType, AppDisplayName, UserPrincipalName
| where ResultType == 0
| summarize
    ['Total Member Signins']=countif(UserType == "Member"),
    ['Distinct Member Signins']=dcountif(UserPrincipalName, UserType == "Member"),
    ['Total Guest Signins']=countif(UserType == "Guest"),
    ['Distinct Guest Signins']=dcountif(UserPrincipalName, UserType == "Guest")
    by AppDisplayName
| sort by AppDisplayName asc  
//Find any Azure AD Service Principals with only incorrect or expired secrets being used and no successful signins. These apps may no longer be in use and can be removed.

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

//Microsoft Sentinel query
AADServicePrincipalSignInLogs
| where TimeGenerated > ago(14d)
| summarize
    ['All Error Codes']=make_set(ResultType)
    by ServicePrincipalId, ServicePrincipalName
| where ['All Error Codes'] !has "0" and ['All Error Codes'] has_any ("7000222", "7000215")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSpnSignInEventsBeta
| where Timestamp > ago(14d)
| summarize
    ['All Error Codes']=make_set(ErrorCode)
    by ServicePrincipalId, ServicePrincipalName
| where ['All Error Codes'] !has "0" and ['All Error Codes'] has_any ("7000222", "7000215")
//Detect when a new credential is added to an Azure AD application registration

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName has "Update application – Certificates and secrets management"
| extend ApplicationName = tostring(TargetResources[0].displayName)
| extend ApplicationObjectId = tostring(TargetResources[0].id)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ActorIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project TimeGenerated, ApplicationName, ApplicationObjectId, Actor, ActorIPAddress
//Detect Azure AD PIM activiations outside of working hours

//Data connector required for this query - Azure Active Directory - Audit Logs

let timerange=30d;
AuditLogs
// extend LocalTime to your time zone
| extend LocalTime=TimeGenerated + 5h
| where LocalTime > ago(timerange)
// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am
| where hourofday(LocalTime) !between (6 .. 18)
| where OperationName == "Add member to role completed (PIM activation)"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| project LocalTime, User, ['Azure AD Role Name'], ['Activation Reason']=ResultReason
//Detects when a user activates a PIM role for the first time on weekends or after working hours

//Data connector required for this query - Azure Active Directory - Audit Logs

let Saturday = time(6.00:00:00);
let Sunday = time(0.00:00:00);
let timeframe = 90d;
//Find users who have previously activated PIM roles outside of business hours or on weekends in the last 90 days
//In this example business hours are 6am to 6pm
let knownusers=
    AuditLogs
    | where TimeGenerated > ago(timeframe) and TimeGenerated < ago(7d)
    // extend LocalTime to your time zone
    | extend LocalTime=TimeGenerated + 5h
    // Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am
    | where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)
    | where OperationName == "Add member to role completed (PIM activation)"
    | extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | distinct User;
//Find users who activate a PIM role outside of business hours or on weekends for the first time in the last week
AuditLogs
| where TimeGenerated > ago(7d)
| extend LocalTime=TimeGenerated + 5h
| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)
| where OperationName == "Add member to role completed (PIM activation)"
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| where User !in (knownusers)
| project LocalTime, User, ['Azure AD Role Name'], ['Activation Reason']=ResultReason
//Create a summary showing which of your Azure AD conditional access policies are preventing the most signins and for what reasons

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (7d)
| project TimeGenerated, ConditionalAccessPolicies, ResultType, ResultDescription
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend ['Conditional Access Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| where CAResult == "failure"
| summarize ['Count of Failures']=count()by ['Conditional Access Policy Name'], ResultType, ResultDescription
| sort by ['Count of Failures'] desc 
//Query to find applications that have had application permissions granted to them

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName has "Add app role assignment to service principal"
| extend UpdatedPermission = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend AppName = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[4].newValue)))
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend AppId = tostring(TargetResources[1].id)
| project TimeGenerated, OperationName, UpdatedPermission, AppName, AppId, User
//Detect when a user has been potentially comrpomised but is stopped by MFA number matching or otherwise denied. Even if stopped by MFA the users credentials need to be rotated.

//Data connector required for this query - Azure Active Directory - Signin Logs

//This query finds any time a user denies an authentication, enters the wrong number or just doesn't respond three or more times in a single sign in event
SigninLogs
| project
    TimeGenerated,
    AuthenticationRequirement,
    AuthenticationDetails,
    UserPrincipalName,
    CorrelationId,
    ResultType
| where ResultType == 500121
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
| where AuthResult in ("MFA denied; user did not select the correct number", "MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification")
//Create a list of denied MFA challenges by sign in attempt (single CorrelationId)
| summarize ['Result Types']=make_list(AuthResult) by CorrelationId, UserPrincipalName
//Find results where there are at least 3 failures within the same sign in, i.e three denies, three did not respond events or three did not select the correct number
| where array_length( ['Result Types']) > 2

//This is the same query but grouped by username and 10 minute period, in case the attacker is starting a new authentication flow and generates a new CorrelationId
SigninLogs
| project
    TimeGenerated,
    AuthenticationRequirement,
    AuthenticationDetails,
    UserPrincipalName,
    CorrelationId,
    ResultType
| where ResultType == 500121
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
| where AuthResult in ("MFA denied; user did not select the correct number", "MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification")
//Create a list of denied MFA challenges by UserPrincipalName and 10 minute window (to account for multiple sign in attempts)
| summarize ['Result Types']=make_list(AuthResult) by UserPrincipalName, bin(TimeGenerated, 10m)
//Find results where there are at least 3 failures within the same sign in, i.e three denies, three did not respond events or three did not select the correct number
| where array_length( ['Result Types']) > 2
//Detect when another Azure AD tenant is added to cross-tenant settings and for each tenant added, retrieve any domain names from your sign in data.
//First retrieve the event where a cross-tenant setting was added

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Azure Active Directory - Signin Logs

AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName == "Add a partner to cross-tenant access setting"
| where Result == "success"
| extend GuestTenantId = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeGenerated, OperationName, Actor, GuestTenantId
//join back to Azure AD sign in logs for the last 30 days to retrieve inbound guest activity
| join kind=inner (
    SigninLogs
    | where TimeGenerated > ago (180d)
    | where UserType == "Guest"
    | where ResultType == 0
    | where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
    //Split all the domains belonging to inbound guest domains and summarize the list per TenantId
    | extend ['Guest Domains'] = split(UserPrincipalName, '@')[-1]
    | summarize ['Guest Domain Names']=make_set(['Guest Domains']) by HomeTenantId)
    //Join back to the audit even where the TenantId from the added setting matches the sign in data
    on $left.GuestTenantId == $right.HomeTenantId
| project-away HomeTenantId
//Find Managed Identity service principals that have not successfully signed in in the last 30 days, for each Managed Identity list the Azure resources it has accessed
//Hopefully it means the resource has already been decommissioned, if not, check to see if it still requires the access it has been granted

//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs

//First find any Managed Identities that haven't successfully signed on for 30 days
AADManagedIdentitySignInLogs
| where TimeGenerated > ago(365d)
| where ResultType == "0"
| summarize arg_max(TimeGenerated, *) by AppId
| extend ['Days Since Last Signin'] = datetime_diff("day", now(), TimeGenerated)
| project
    ['Last Sign in Time']=TimeGenerated,
    ServicePrincipalName,
    ServicePrincipalId,
    ['Days Since Last Signin'],
    AppId
| where ['Days Since Last Signin'] > 30
//Join that list of Managed Identities back to the sign in data and retrieve the Azure resources (such as Key Vault or Storage) it has accessed
| join kind=inner (
    AADManagedIdentitySignInLogs
    | where TimeGenerated > ago(365d)
    | where ResultType == "0"
    | summarize ['Resources Accessed']=make_set(ResourceDisplayName) by AppId)
    on AppId
| project-reorder
    ['Last Sign in Time'],
    ['Days Since Last Signin'],
    ServicePrincipalName,
    ServicePrincipalId,
    AppId,
    ['Resources Accessed']
| order by ['Days Since Last Signin'] desc

//mv-apply parser to retrieve the Authentication requirements for an Azure AD Sign in

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| mv-apply arp = todynamic(AuthenticationRequirementPolicies) on 
    (extend requirementProvider = tostring(arp.requirementProvider)
    )
| project  
    TimeGenerated,
    UserPrincipalName,
    AppDisplayName,
    AuthenticationRequirement,
    requirementProvider,
    CorrelationId
//Detect when a user denies MFA several times within a single sign in attempt and then completes MFA.
//This could be a sign of someone trying to spam your users with MFA prompts until they accept.

//Data connector required for this query - Azure Active Directory - Signin Logs

//Select your threshold of how many times a user denies MFA before accepting
let threshold=2;
SigninLogs
| project
    TimeGenerated,
    AuthenticationRequirement,
    AuthenticationDetails,
    UserPrincipalName,
    CorrelationId
//Include only authentications that require MFA
| where AuthenticationRequirement == "multiFactorAuthentication"
//Extend authentication result description
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
//Find results that include both denined and completed MFA
| where AuthResult in ("MFA completed in Azure AD", "MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification","MFA successfully completed")
//Create a list of completed and denied MFA challenges per correlation id
| summarize ['Result Types']=make_list(AuthResult) by CorrelationId, UserPrincipalName
//Ensure the list includes both completed and denied MFA challenges
| where ['Result Types'] has_any ("MFA completed in Azure AD","MFA successfully completed") and ['Result Types'] has_any ("MFA denied; user declined the authentication", "MFA denied; user did not respond to mobile app notification")
| mv-expand ['Result Types'] to typeof(string)
//Expand and count all the denied challenges and then return CorrelationId's where the MFA denied count is greater or equal to your threshold
| where ['Result Types'] has_any ("MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification")
| summarize ['Denied MFA Count']=count()by ['Result Types'], CorrelationId, UserPrincipalName
| where ['Denied MFA Count'] >= threshold

//Alternate query, instead of grouping signins by CorrelationId we group them by UserPrincipalName and 10 minute blocks of time.
//In case the bad actor is starting a whole new sign in each time and generating a new CorrelationId for each attempt.
//Select your threshold of how many times a user denies MFA before accepting
let threshold=2;
SigninLogs
| project
    TimeGenerated,
    AuthenticationRequirement,
    AuthenticationDetails,
    UserPrincipalName,
    CorrelationId
//Include only authentications that require MFA
| where AuthenticationRequirement == "multiFactorAuthentication"
//Extend authentication result description
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
//Find results that include both denined and completed MFA
| where AuthResult in ("MFA completed in Azure AD", "MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification","MFA successfully completed")
//Create a list of completed and denied MFA challenges per user principal name over 10 minute periods
| summarize ['Result Types']=make_list(AuthResult) by UserPrincipalName, bin(TimeGenerated, 10m)
//Ensure the list includes both completed and denied MFA challenges
| where ['Result Types'] has_any ("MFA completed in Azure AD","MFA successfully completed") and ['Result Types'] has_any ("MFA denied; user declined the authentication", "MFA denied; user did not respond to mobile app notification")
| mv-expand ['Result Types'] to typeof(string)
//Expand and count all the denied challenges and then return UserPrincipalNames where the MFA denied count is greater or equal to your threshold
| where ['Result Types'] has_any ("MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification")
| summarize ['Denied MFA Count']=count()by ['Result Types'], UserPrincipalName
| where ['Denied MFA Count'] >= threshold

//Simple query to count users being spammed with denies or not responding in one hour time windows
SigninLogs
| project
    TimeGenerated,
    AuthenticationRequirement,
    AuthenticationDetails,
    UserPrincipalName,
    CorrelationId
| where AuthenticationRequirement == "multiFactorAuthentication"
//Extend authentication result description
| mv-expand todynamic(AuthenticationDetails)
| extend AuthResult = tostring(parse_json(AuthenticationDetails).authenticationStepResultDetail)
| where AuthResult in ("MFA denied; user declined the authentication","MFA denied; user did not respond to mobile app notification")
| summarize ['Result Types']=make_list(AuthResult), ['Result Count']=count() by UserPrincipalName, bin(TimeGenerated, 60m)
//Find hits with greater than 3 failures in an hour
| where ['Result Count'] > 3
//Find Azure AD service principals that are logging on from multiple locations, this should be less common than with user accounts

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

//Return the IP addresses used to sign in and see if you can build conditional access policies around them
//Microsoft Sentinel Query
AADServicePrincipalSignInLogs
| where TimeGenerated > ago(30d)
| where ResultType == "0"
| where isnotempty(Location)
| summarize
    ['Count of Locations']=dcount(Location),
    ['List of Locations']=make_set(Location),
    ['Count of IP Addresses']=dcount(IPAddress),
    ['List of IP Addresses']=make_set(IPAddress)
    by ServicePrincipalName, AppId
| where ['Count of Locations'] >= 2

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSpnSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == "0"
| where isnotempty(Country)
| summarize
    ['Count of Locations']=dcount(Country),
    ['List of Locations']=make_set(Country),
    ['Count of IP Addresses']=dcount(IPAddress),
    ['List of IP Addresses']=make_set(IPAddress)
    by ServicePrincipalName, ApplicationId
| where ['Count of Locations'] >= 2


//Summarize the usage of all your applications from last month to this month. Usage is calculated by distinct users per application.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(60d)
| where ResultType == "0"
| summarize
    ['Last Month Signins']=dcountif(UserPrincipalName, TimeGenerated > ago(60d) and TimeGenerated < ago(30d)),
    ['This Month Signins']=dcountif(UserPrincipalName, TimeGenerated > ago(30d))
    by AppId, AppDisplayName
| extend ['Percentage Change']=(todouble(['This Month Signins'] - todouble(['Last Month Signins'])) / todouble(['Last Month Signins']) * 100)
| sort by AppDisplayName asc 
//Summarize legacy auth authentications by type (such as ActiveSync, IMAP etc) and which accounts are using those protocols

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
union SigninLogs, AADNonInteractiveUserSignInLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize ['Count of legacy auth attempts'] = count()by ClientAppUsed, UserPrincipalName
| sort by ClientAppUsed asc, ['Count of legacy auth attempts'] desc 

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(30d)
| where ErrorCode == 0
| where ClientAppUsed in ("Exchange ActiveSync", "Exchange Web Services", "AutoDiscover", "Unknown", "POP3", "IMAP4", "Other clients", "Authenticated SMTP", "MAPI Over HTTP", "Offline Address Book")
| summarize ['Count of legacy auth attempts'] = count()by ClientAppUsed, AccountUpn
| sort by ClientAppUsed asc, ['Count of legacy auth attempts'] desc 
//Visualizes conditional access policy failures over time by policy name

//Data connector required for this query - Azure Active Directory - Signin Logs

let start = now(-90d);
let end = now();
let timeframe= 12h;
SigninLogs
| project TimeGenerated, ResultType, ConditionalAccessPolicies
| where ResultType == 53003
| mv-expand ConditionalAccessPolicies
| where ConditionalAccessPolicies.result == "failure"
| extend ['CA Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| make-series ['Failure Count'] = count() default=0 on TimeGenerated in range(start, end, timeframe) by ['CA Policy Name']
| render timechart with (title="Conditional access policy failure over time")
//Finds Azure AD audit events from users who hold admin privileges (based on PIM activations in the last 60 days) and then finds any audit events events from those users in the last 7 days that have elevated risk associated to them
//This query is part of The Definitive Guide to KQL: Using Kusto Query Language for Operations, Defending, and Threat Hunting - https://aka.ms/KQLMSPress and was contributed by Corissa K - https://www.linkedin.com/in/corissakoopmans/

//Data connector required for this query - Azure Active Directory - Audit Logs

let privroles = pack_array("Application Administrator","Authentication Administrator","Cloud Application Administrator","Conditional Access Administrator","Exchange Administrator","Global Administrator","Helpdesk Administrator","Hybrid Identity Administrator","Password Administrator","Privileged Authentication Administrator","Privileged Role Administrator","Security Administrator","SharePoint Administrator","User Administrator");
let privusers = AuditLogs 
| where TimeGenerated > ago(60d) and ActivityDisplayName == 'Add member to role completed (PIM activation)' and Category == "RoleManagement" 
| extend Caller = tostring(InitiatedBy.user.userPrincipalName) 
| extend Role = tostring(TargetResources[0].displayName) 
| where Role in (privroles) 
| distinct Caller;
let Activity =  AuditLogs
    | mv-expand ParsedFields = parse_json(TargetResources)
    | extend Target = tostring(ParsedFields.userPrincipalName), DisplayName = tostring(ParsedFields.displayName)
    | project TimeGenerated, Target, DisplayName, ParsedFields, OperationName;
    let RiskyUsers = SigninLogs
    | where RiskLevelDuringSignIn == "high"
    | where RiskState == "atRisk"
    | project TimeGenerated,UserPrincipalName, UserDisplayName, RiskDetail, RiskLevelDuringSignIn, RiskState;
    Activity
    | join kind=inner(RiskyUsers) on $left.DisplayName==$right.UserDisplayName
    | where TimeGenerated >= ago(7d) and UserPrincipalName in~ (privusers)
    | distinct UserDisplayName, RiskDetail, RiskLevelDuringSignIn, OperationName

//Create a temporary table of first party apps from the following sources which are updated daily in the following order
//        1. Microsoft Graph (apps where appOwnerOrganizationId is Microsoft)
//        2. Microsoft Learn doc (https://learn.microsoft.com/troubleshoot/azure/active-directory/verify-first-party-apps-sign-in)
//        3. Custom list of apps (./customdata/MysteryApps.csv) - Community contributed list of Microsoft apps and their app ids
//You can then look up / join this to any data that does not have the friendly name or just use it as a reference
//See https://github.com/merill/microsoft-info for the reference source

let FirstPartyApps = externaldata (AppId:guid,AppDisplayName:string,AppOwnerOrganizationId:guid,Source:string) [
    h@'https://raw.githubusercontent.com/merill/microsoft-info/main/_info/MicrosoftApps.json'
    ] with(format='multijson');
FirstPartyApps
//List the bulk activities attempted by your privileged Azure AD users and parse the results

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName has_all ("(bulk)", "finished")
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeGenerated, Actor, ResultDescription, OperationName
| parse ResultDescription with * "Total activities count:" ['Total Activity Count'] ";" *
| parse ResultDescription with * "succeeded activities count" ['Total Succeeded'] ";" *
| parse ResultDescription with * "failed activities count" ['Total Failed']
| project
    TimeGenerated,
    Actor,
    OperationName,
    ['Total Activity Count'],
    ['Total Succeeded'],
    ['Total Failed'] 
//Visualize successful vs failed self service password reset attempts in your Azure AD tenant

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago (30d)
| where LoggedByService == "Self-service Password Management"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| sort by TimeGenerated asc 
//Create a list of all SSPR actions that make up a single correlation id which represents one attempts at completing SSPR
| summarize ['SSPR Actions']=make_list(ResultReason) by CorrelationId, bin(TimeGenerated, 1d)
//Summarize those lists of actions into those that have a successful password reset and those that don't
| summarize
    ['Successful self service password resets']=countif(['SSPR Actions'] has "Successfully completed reset"),
    ['Failed self service password resets']=countif(['SSPR Actions'] !has "User successfully reset password")
    by bin(TimeGenerated, 1d) 
| render timechart with (title="Self service password reset success vs failure", ytitle="Count")
//Query to parse IP information from Security Alerts

//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)

SecurityAlert
| where AlertName in ("Impossible travel activity", "Atypical Travel", "Anonymous IP address", "Anomalous Token")
| parse Entities with * 'AadUserId": "' aadid_ '",' *
| extend ep_ = parse_json(ExtendedProperties)
| extend s = tostring(ep_["IP Addresses"])
| extend ipv4_ = extract_all(@"(([\d]{1,3}\.){3}[\d]{1,3})", dynamic([1]), s)
| extend ipv4Add_ = translate('["]', '', tostring(ipv4_))
| extend ipv6_ = extract_all(@"(([\d|\w]{1,4}\:){7}[\d|\w]{1,4})", dynamic([1]), s)
| extend ipv6Add_ = translate('["]', '', tostring(ipv6_))
| project TimeGenerated, AlertName, ipv4Add_, ipv6Add_, CompromisedEntity
//Detects users who add, delete or update a Azure AD Conditional Access policy for the first time.
//First find users who have previously made CA policy changes, this example looks back 90 days

//Data connector required for this query - Azure Active Directory - Audit Logs

let knownusers=
    AuditLogs
    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
    | where OperationName in ("Update conditional access policy", "Add conditional access policy", "Delete conditional access policy")
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | distinct Actor;
//Find new events from users not in the known user list
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName in ("Update conditional access policy", "Add conditional access policy", "Delete conditional access policy")
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Policy Name'] = tostring(TargetResources[0].displayName)
| extend ['Policy Id'] = tostring(TargetResources[0].id)
| where Actor !in (knownusers)
| project TimeGenerated, Actor, ['Policy Name'], ['Policy Id']
//Parses the user agent into its various components to allow hunting on specific browser versions or patch levels

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| extend UserAgentDetail = todynamic(parse_user_agent(UserAgent, "browser"))
| extend UserAgentFamily = tostring(parse_json(tostring(UserAgentDetail.Browser)).Family)
| extend UserAgentMajorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MajorVersion)
| extend UserAgentMinorVersion = toint(parse_json(tostring(UserAgentDetail.Browser)).MinorVersion)
| extend UserAgentPatch = toint(parse_json(tostring(UserAgentDetail.Browser)).Patch)
| project
    TimeGenerated,
    UserPrincipalName,
    AppDisplayName,
    ResultType,
    IPAddress,
    Location,
    UserAgentFamily,
    UserAgentMajorVersion,
    UserAgentMinorVersion,
    UserAgentPatch,
    UserAgent
//Visualize your sign ins over a world map
//This visualization is supported in the Kusto Explorer app or the Web UI
//You can install the app here - https://learn.microsoft.com/en-us/azure/data-explorer/kusto/tools/kusto-explorer

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (90d)
| extend BeginLat = toreal(parse_json(tostring(LocationDetails.geoCoordinates)).latitude)
| extend BeginLon = toreal(parse_json(tostring(LocationDetails.geoCoordinates)).longitude)
| summarize Count=count() by BeginLon, BeginLat
| project-reorder BeginLon, BeginLat, Count
| where isnotempty(BeginLon)
| render scatterchart with (kind=map)
//Retrieve sign in failures due to third party MFA (Okta/Duo etc). Azure AD handles third party MFA different to native MS MFA. A user is sent to the third party MFA service and generates code 50158.
//If successful the user then generates a success code 0. When third party MFA fails Azure AD logs the 50158 result code but no corresponding 0 result code.

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
//Create a list of all result codes within a single sign in to Azure AD
| summarize MFA=make_list(ResultType) by CorrelationId
//Find correlation ids where the user was sent to third party MFA (ResultType 50158) but there is no subsequent success (ResultType 0)
| where MFA has "50158" and MFA !has "0"
//Join back to SigninLogs table to find the sign in details
| join kind=inner (SigninLogs) on CorrelationId
| project
    TimeGenerated,
    UserPrincipalName,
    UserType,
    AppDisplayName,
    IPAddress,
    Location,
    UserAgent,
    ResultType

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
//Create a list of all result codes within a single sign in to Azure AD
| summarize MFA=make_list(ErrorCode) by CorrelationId
//Find correlation ids where the user was sent to third party MFA (ResultType 50158) but there is no subsequent success (ResultType 0)
| where MFA has "50158" and MFA !has "0"
//Join back to SigninLogs table to find the sign in details
| join kind=inner (AADSignInEventsBeta) on CorrelationId
| project
    Timestamp,
    AccountUpn,
    IsGuestUser,
    Application,
    IPAddress,
    Country,
    UserAgent,
    ErrorCode
//Find guest accounts that haven't signed in for a period of time, this example uses 45 days

//Data connector required for this query - Azure Active Directory - Signin Logs

let timerange=180d;
let timeframe=45d;
SigninLogs
| where TimeGenerated > ago(timerange)
| where UserType == "Guest" or UserPrincipalName contains "#ext#"
| where ResultType == 0
| summarize arg_max(TimeGenerated, *) by UserPrincipalName
| join kind = leftanti  
    (
    SigninLogs
    | where TimeGenerated > ago(timeframe)
    | where UserType == "Guest" or UserPrincipalName contains "#ext#"
    | where ResultType == 0
    | summarize arg_max(TimeGenerated, *) by UserPrincipalName
    )
    on UserPrincipalName
| project UserPrincipalName

//Find potentially compromised accounts trying to pivot into other apps by detecting 3 or more distinct Conditional Access failures or 3 or more failures to apps the account has no access to

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (1d)
| where ResultType in ("50105", "53003")
| summarize
    TotalCount=count(),
    ['Total Distinct Failed Apps']=make_set(AppDisplayName),
    ['List of distinct failed CA Apps']=make_set_if(AppDisplayName, ResultType == 53003),
    ['List of distinct no access Apps']=make_set_if(AppDisplayName, ResultType == 50105)
    by UserPrincipalName, bin(TimeGenerated, 1h)
| extend
    ['Count of distinct failed CA Apps']=array_length(['List of distinct failed CA Apps']),
    ['Count of distinct failed no access Apps']=array_length(['List of distinct no access Apps'])
| where ['Count of distinct failed CA Apps'] >= 3 or ['Count of distinct failed no access Apps'] >= 3

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago (1d)
| where ErrorCode in ("50105", "53003")
| summarize
    TotalCount=count(),
    ['Total Distinct Failed Apps']=make_set(Application),
    ['List of distinct failed CA Apps']=make_set_if(Application, ErrorCode == 53003),
    ['List of distinct no access Apps']=make_set_if(Application, ErrorCode == 50105)
    by AccountUpn, bin(Timestamp, 1h)
| extend
    ['Count of distinct failed CA Apps']=array_length(['List of distinct failed CA Apps']),
    ['Count of distinct failed no access Apps']=array_length(['List of distinct no access Apps'])
| where ['Count of distinct failed CA Apps'] >= 3 or ['Count of distinct failed no access Apps'] >= 3
//Visualize how many guests are redeeming invites over the time period with trend

//Data connector required for this query - Azure Active Directory - Audit Logs

let StartDate = now(-180d);
let EndDate = now();
AuditLogs
| where OperationName == "Redeem external user invite"
| make-series TotalInvites=count() on TimeGenerated in range(StartDate, EndDate, 1d)
| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalInvites)
| project TimeGenerated, TotalInvites, TrendLine
| render timechart with (title="Guest Invites redeemed over time with trend")
//Find users who hold a privileged Azure AD role but haven't completed any activities in Azure AD for 45 days

//Data connector required for this query - Azure Active Directory - Audit Logs
//Data connector required for this query - Microsoft Sentinel UEBA

//Lookup the IdentityInfo table for any users holding a privileged role
IdentityInfo
| where TimeGenerated > ago(21d)
| summarize arg_max(TimeGenerated, *) by AccountUPN
| where isnotempty(AssignedRoles)
| where AssignedRoles != "[]"
| project UserPrincipalName=AccountUPN, AssignedRoles
| join kind=leftanti (
    AuditLogs
    | where TimeGenerated > ago(45d)
    | extend UserPrincipalName = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where isnotempty(UserPrincipalName)
    | distinct UserPrincipalName
    )
    on UserPrincipalName
//Detect when a user activates an Azure AD PIM role never seen by them before

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(180d) and TimeGenerated < ago(1d)
| where OperationName == "Add member to role completed (PIM activation)"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| distinct User, ['Azure AD Role Name']
| join kind=rightanti (
    AuditLogs
    | where TimeGenerated > ago(1d)
    | where OperationName == "Add member to role completed (PIM activation)"
    | extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
    )
    on User, ['Azure AD Role Name']
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project TimeGenerated, User, ['Azure AD Role Name']
//Detect when an Azure AD Entitlement Package is created. You may want to review to see what resources and roles have been included in the package.

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName == "Create access package"
| where TargetResources[0].type == "AccessPackage"
| extend AccessPackageName = tostring(TargetResources[0].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeGenerated, OperationName, AccessPackageName, Actor
//Find sign ins where your users signed into other Azure AD tenants as outbound guests

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where AADTenantId == HomeTenantId
| where ResourceTenantId != AADTenantId
| where UserType == "Guest"
| project
    TimeGenerated,
    AppDisplayName,
    UserPrincipalName,
    ResultType,
    Location,
    IPAddress,
    ['Guest Tenant Id']=ResourceTenantId
//Detect users who are trying to use self service password reset but failing as they don't have any authentication methods listed

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where LoggedByService == "Self-service Password Management"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| sort by TimeGenerated asc 
| summarize ['SSPR Actions']=make_list(ResultReason) by CorrelationId, User, ['User IP Address']
| where ['SSPR Actions'] has "User's account has insufficient authentication methods defined. Add authentication info to resolve this"
| sort by User desc 
//Detect when a user is blocked by Conditional Access after failing 3 unique CA policies or 3 unique applications over a 2 hour period

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(1d)
| where ResultType == "53003"
| mv-expand ConditionalAccessPolicies
| extend ['CA Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| where ConditionalAccessPolicies.result == "failure"
| summarize
    ['Total count of logon failures']=count(),
    ['Count of failed applications']=dcount(AppDisplayName),
    ['List of failed applications']=make_set(AppDisplayName),
    ['Count of failed policy names']=dcount(['CA Policy Name']),
    ['List of failed policy names']=make_set(['CA Policy Name'])
    by UserPrincipalName, bin(TimeGenerated, 2h)
| where ['Count of failed applications'] >= 3 or ['Count of failed policy names'] >= 3
//Query to find applications that have had delegated permissions granted to them

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where Category == "ApplicationManagement"
| where OperationName has "Add delegated permission grant"
| extend UpdatedPermissions = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue))) 
| extend AppId = tostring(TargetResources[1].id)
| project TimeGenerated, UpdatedPermissions, OperationName, AppId
//Detect anomalies in the amount of conditional access failures by users in your tenant, then visualize those conditional access failures

//Data connector required for this query - Azure Active Directory - Signin Logs

//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.
let startdate=21d;
let enddate=1d;
//Timeframe = time period to break the data up into, i.e 1 hour blocks.
let timeframe=1h;
//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5
let sensitivity=2;
//Threshold = set this to tune out low count anomalies, i.e when total failures for a user doubles from 1 to 2
let threshold=5;
let outlierusers=
SigninLogs
| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))
| where ResultType == "53003"
| project TimeGenerated, ResultType, UserPrincipalName
| make-series CAFailureCount=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserPrincipalName 
| extend outliers=series_decompose_anomalies(CAFailureCount, sensitivity)
| mv-expand TimeGenerated, CAFailureCount, outliers
| where outliers == 1 and CAFailureCount > threshold
| distinct UserPrincipalName;
//Optionally visualize the anomalies
SigninLogs
| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))
| where ResultType == "53003"
| project TimeGenerated, ResultType, UserPrincipalName
| where UserPrincipalName in (outlierusers)
| summarize CAFailures=count()by UserPrincipalName, bin(TimeGenerated, timeframe)
| render timechart with (ytitle="Failure Count",title="Anomalous Conditional Access Failures")
//Summarize accounts (both members and guests) that haven't signed on for over 60 days, and summarize them into the month they last signed in

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (365d)
| where ResultType == 0
| where isnotempty(UserType)
| summarize arg_max(TimeGenerated, *) by UserPrincipalName
| where TimeGenerated < ago(60d)
| summarize
    ['Inactive Account List']=make_set(UserPrincipalName),
    ['Count of Inactive Accounts']=dcount(UserPrincipalName)
    by UserType, Month=startofmonth(TimeGenerated)
| sort by Month desc, UserType asc   
//Detect when a user adds delegated or application permissions to an Azure AD app for the first time.

//Data connector required for this query - Azure Active Directory - Audit Logs

//Look back in the last year to find all users who have added access to an app
let newusers=
AuditLogs
| where TimeGenerated > ago(365d) and TimeGenerated < ago(1d)
| where OperationName in ("Add app role assignment to service principal","Add delegated permission grant")
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| distinct Actor
//Find users who add access to an app for the first time in the last day
| join kind=rightanti (
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName in ("Add app role assignment to service principal","Add delegated permission grant")
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| distinct Actor )
on Actor;
//Retrieve the list of permissions granted by the first time users
let delegatedaccess=
    AuditLogs
    | where TimeGenerated > ago(1d)
    | where OperationName has "Add delegated permission grant"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where Actor in (newusers)
    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)
    | extend Activity = strcat("Delegated access added to application")
    | project
        TimeGenerated,
        Activity,
        ['Permissions granted'],
        ['Service Principal ObjectId'],
        Actor;
let appaccess=
    AuditLogs
    | where TimeGenerated > ago(1d)
    | where OperationName has "Add app role assignment to service principal"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | where Actor in (newusers)
    | extend Activity = strcat("Application access added to application")
    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)
    | project
        TimeGenerated,
        Activity,
        ['Permissions granted'],
        ['Service Principal ObjectId'],
        Actor;
union delegatedaccess, appaccess

//Summarize the Azure resources that each of your managed identities are accessing. The higher the count the higher the potential blast radius.

//Data connector required for this query - Azure Active Directory - Managed Identity Signin Logs

AADManagedIdentitySignInLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| summarize
    ['List of Azure Resources Accessed']=make_set(ResourceDisplayName),
    ['Distinct Resources Accessed']=dcount(ResourceDisplayName)
    by ServicePrincipalName
| sort by ['Distinct Resources Accessed'] desc 
//Detect when a service principal is added to Azure AD after working hours or on weekends

//Data connector required for this query - Azure Active Directory - Audit Logs

let Saturday = time(6.00:00:00);
let Sunday = time(0.00:00:00);
AuditLogs
| where TimeGenerated > ago(7d)
// extend LocalTime to your time zone
| extend LocalTime=TimeGenerated + 5h
// Change hours of the day to suit your company, i.e this would find activations between 6pm and 6am
| where dayofweek(LocalTime) in (Saturday, Sunday) or hourofday(LocalTime) !between (6 .. 18)
| where OperationName == "Add service principal"
//Exclude service principals created by managed identities (if you have automation tasks running this may trigger), but you can remove the exclusion if required
| where parse_json(tostring(InitiatedBy.app)).displayName != "Managed Service Identity"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend AppId = tostring(AdditionalDetails[1].value)
| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project LocalTime, Actor, ['Actor IP Address'], AppId

//Find users who have successfully signed into Azure AD from 3 or more countries in the same day

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
SigninLogs
| where TimeGenerated > ago(7d)
| where ResultType == 0
| where isnotempty(Location)
| summarize
    ['Count of countries']=dcount(Location),
    ['List of countries']=make_set(Location)
    by UserPrincipalName, bin(TimeGenerated, 1d)
| where ['Count of countries'] >= 3

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Timestamp > ago(7d)
| where ErrorCode == 0
| where isnotempty(Country)
| summarize
    ['Count of countries']=dcount(Country),
    ['List of countries']=make_set(Country)
    by AccountUpn, bin(Timestamp, 1d)
| where ['Count of countries'] >= 3
//Group your Azure AD guest accounts into the month they last signed in

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (360d)
| where UserType == "Guest" or UserPrincipalName contains "#ext#"
| where ResultType == 0
| summarize arg_max(TimeGenerated, *) by UserPrincipalName
| project TimeGenerated, UserPrincipalName
| summarize ['Inactive Guest Accounts']=make_set(UserPrincipalName) by Month=startofmonth(TimeGenerated)
| sort by Month desc  
//Calculate the percentage of signins failing against each of your Conditional Access policies. If the percentage is high it may be worth evaulating the policy if it is fit for purpose.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| project ConditionalAccessPolicies
| extend CA = parse_json(ConditionalAccessPolicies)
| mv-expand bagexpansion=array CA
| extend ['CA Policy Name'] = tostring(CA.displayName)
| extend  ['CA Outcome'] = tostring(CA.result)
| summarize
    ['Total Signin Count']=count(),
    ['Total Failed Count']=countif(['CA Outcome'] == "failure")
    by ['CA Policy Name']
| extend ['Failed Percentage'] = todouble(['Total Failed Count']) * 100 / todouble(['Total Signin Count'])
| project-reorder
    ['CA Policy Name'],
    ['Total Signin Count'],
    ['Total Failed Count'],
    ['Failed Percentage']
| order by ['Failed Percentage']
//When a user registers or updates MFA details, take that IP address and summarize sign in events for that user and IP address for the last 30 days.
//If they have never signed in or signed in a few times from that IP it may a sign the account has been compromised and a threat actor has added MFA details

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - Audit Logs

let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
AuditLogs
| where TimeGenerated > ago(1d)
| where OperationName in~ ("Admin registered security info", "Admin updated security info", "Admin deleted security info", "User registered security info", "User changed default security info", "User deleted security info")
| extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
| extend IPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| project ['MFA Event Time']=TimeGenerated, OperationName, UserPrincipalName, IPAddress
| join kind=inner(
    SigninLogs
    | where TimeGenerated > ago (30d)
    )
    on UserPrincipalName, IPAddress
| project
    TimeGenerated,
    ['MFA Event Time'],
    OperationName,
    ResultType,
    UserPrincipalName,
    IPAddress
| summarize
    ['Count of successful sign ins from MFA IP Address'] = countif(ResultType in(successCodes)),
    ['Count of failed sign ins from MFA IP Address'] = countif(ResultType in(failureCodes))
    by UserPrincipalName, OperationName, IPAddress, ['MFA Event Time']

//Visualize inbound Azure AD guests (other tenants connecting to your tenant) vs outbound (your users connecting to other tenants)

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| where UserType == "Guest"
| where ResultType == 0
| summarize
    ['Inbound Guests']=countif(AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId),
    ['Outbound Guests']=countif(AADTenantId == HomeTenantId and ResourceTenantId != AADTenantId)
    by bin(TimeGenerated, 1d)
| render timechart with (title="Inbound Guest vs Outbound Guest Access", ytitle="Number of connections")
//Visualize when your users are actively challenged for MFA vs when it was previously satisfied

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(90d)
| where AuthenticationRequirement == "multiFactorAuthentication"
| mv-expand todynamic(AuthenticationDetails)
| project TimeGenerated, AuthenticationDetails
| extend MFAResultStep = tostring(AuthenticationDetails.authenticationStepResultDetail)
| summarize
    MFARequired=countif(MFAResultStep == "MFA completed in Azure AD"),
    PreviouslySatisfied=countif(MFAResultStep == "MFA requirement satisfied by claim in the token")
    by bin(TimeGenerated, 1d)
| render timechart
    with (
    xtitle="Day",
    ytitle="Count",
    title="MFA challenges vs MFA previously satisfied over time")
//Detect when Advanced Auditing is disabled for a user
//Reference - https://www.mandiant.com/resources/remediation-and-hardening-strategies-microsoft-365-defend-against-apt29-v13

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Update user"
| where Result == "success"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend targetResources=parse_json(TargetResources)
| extend Target = tostring(TargetResources[0].userPrincipalName)
| extend ['Target ObjectId'] = tostring(TargetResources[0].id)
| mv-apply tr = targetResources on (
    extend targetResource = tr.displayName
    | mv-apply mp = tr.modifiedProperties on (
        where mp.displayName == "LicenseAssignmentDetail"
        | extend NewValue = tostring(mp.newValue)
        ))
| mv-expand todynamic(NewValue)
| where parse_json(tostring(NewValue.DisabledPlans))[0] == "2f442157-a11c-46b9-ae5b-6e39ff4e5849"
| project
    TimeGenerated,
    Actor,
    Target,
    ['Target ObjectId'],
    Activity="Advanced Auditing Disabled"
//Detect AADInternals use, where we see a domain changed from managed to federated, and the issuer contains any.sts or the issuer suffix is 8 characters, a combination of letters and numbers

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Set domain authentication"
| extend DomainName = tostring(TargetResources[0].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ActorIPAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend mp=parse_json(TargetResources[0].modifiedProperties)
| mv-apply mp on (
where mp.displayName == "IssuerUri"
| extend Issuer=mp.newValue
)
| extend mp=parse_json(TargetResources[0].modifiedProperties)
| mv-apply mp on (
where mp.displayName == "LiveType"
| extend OldDomainType = mp.oldValue
| extend NewDomainType = mp.newValue
)
| project TimeGenerated, Actor, ActorIPAddress, DomainName, OldDomainType, NewDomainType, Issuer
| parse Issuer with * @'://' Issuer @'"' *
| extend IssuerSuffix = split(Issuer, '/')[-1]
| where OldDomainType has "Managed" and NewDomainType has "Federated"
| where Issuer has "any.sts" or IssuerSuffix matches regex "^[a-zA-Z0-9]{8}$"
//Detect when Azure AD Named Locations are changed (either IP or Country) and retrieve the current list 

//Data connector required for this query - Azure Active Directory - Audit Logs

let updatedip=
    AuditLogs
    | where OperationName == "Update named location"
    | mv-expand TargetResources
    | extend modifiedProperties = parse_json(TargetResources).modifiedProperties
    | mv-expand modifiedProperties  
    | extend newValue = tostring(parse_json(modifiedProperties).newValue)
    | mv-expand todynamic(newValue)
    | extend ipRanges = tostring(parse_json(newValue).ipRanges)
    | mv-expand todynamic(ipRanges) 
    | extend cidr = tostring(ipRanges.cidrAddress)
    | where isnotempty(cidr)
    | extend ['Named Location name'] = tostring(TargetResources.displayName)
    | summarize ['IP List']=make_list(cidr) by ['Named Location name'];
let updatedcountries=
    AuditLogs
    | where OperationName == "Update named location"
    | mv-expand TargetResources
    | extend modifiedProperties = parse_json(TargetResources).modifiedProperties
    | mv-expand modifiedProperties  
    | extend newValue = tostring(parse_json(modifiedProperties).newValue)
    | extend countriesAndRegions = tostring(parse_json(newValue).countriesAndRegions)
    | mv-expand todynamic(countriesAndRegions) 
    | where isnotempty(countriesAndRegions)
    | extend ['Named Location name'] = tostring(TargetResources.displayName)
    | summarize ['Country List']=make_list(countriesAndRegions) by ['Named Location name'];
union updatedip, updatedcountries
//Calculate how often your users are actively challenged for MFA vs when it was previously satisfied per day
//Return users who are challenged over the threshold per day

//Data connector required for this query - Azure Active Directory - Signin Logs

let threshold = 5;
SigninLogs
| where TimeGenerated > ago(90d)
| where AuthenticationRequirement == "multiFactorAuthentication"
| extend x=todynamic(AuthenticationDetails)
| mv-expand x
| project TimeGenerated, x, UserPrincipalName
| extend MFAResultStep = tostring(x.authenticationStepResultDetail)
| summarize MFARequired=countif(MFAResultStep == "MFA completed in Azure AD"), PreviouslySatisfied=countif(MFAResultStep == "MFA requirement satisfied by claim in the token") by UserPrincipalName, startofday(TimeGenerated)
| where MFARequired >= threshold
//Detect potential device code phishing by finding sign ins with both a error 50199 (additional approval required) and error code 0 (success)

//Depending on the size of your tenant - or if you have developers or devices using these flows you may get false positives. 
//The second query looks for new UserPrincipalNames triggering this sign on flow not previously seen in the last 30 days
//The third query searches for a new combination of both UserPrincipalName AND IPAddress not seen in the last 30 days

//Data connector required for this query - Azure Active Directory - Signin Logs

let suspiciousids=
SigninLogs
| where TimeGenerated > ago (1d)
| where ResultType in (0,50199)
| summarize Results=make_set(ResultType) by CorrelationId
| where Results has_all (0, 50199)
| distinct CorrelationId;
SigninLogs
| where CorrelationId in (suspiciousids)
| project TimeGenerated, UserPrincipalName, Location, IPAddress, UserAgent, ResultType


let knownusers=
SigninLogs
| where TimeGenerated > ago (30d) and TimeGenerated < ago(1d)
| where ResultType in (0,50199)
| summarize Results=make_set(ResultType) by CorrelationId, UserPrincipalName
| where Results has_all (0, 50199)
| distinct UserPrincipalName;
let suspiciousids=
SigninLogs
| where TimeGenerated > ago (1d)
| where ResultType in (0,50199)
| summarize Results=make_set(ResultType) by CorrelationId, UserPrincipalName
| where Results has_all (0, 50199)
| where UserPrincipalName !in (knownusers)
| distinct CorrelationId;
SigninLogs
| where CorrelationId in (suspiciousids)
| project TimeGenerated, UserPrincipalName, Location, IPAddress, UserAgent, ResultType


let suspiciousids=
SigninLogs
| where TimeGenerated > ago (30d) and TimeGenerated < ago(1d)
| where ResultType in (0, 50199)
| summarize Results=make_set(ResultType) by CorrelationId, UserPrincipalName, IPAddress
| where Results has_all (0, 50199)
| distinct UserPrincipalName, IPAddress
| join kind=rightanti (
    SigninLogs
    | where TimeGenerated > ago (1d)
    | where ResultType in (0, 50199)
    | summarize Results=make_set(ResultType) by CorrelationId, UserPrincipalName, IPAddress
    | where Results has_all (0, 50199)
    ) 
    on UserPrincipalName, IPAddress
    | distinct CorrelationId;
SigninLogs
| where CorrelationId in (suspiciousids)
| project TimeGenerated, UserPrincipalName, Location, IPAddress, UserAgent, ResultType
//Looks for potential AiTM phishing by finding sign ins with the following properties - has error codes 50074 (MFA required), 50140 (keep me signed in prompt) and 0 (success)
//It also looks for high or medium risk events and where there are multiple session id's per correlation id (per single sign in flow)

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel doesn't track SessionId like Advanced Hunting does so you may end up with a few more false positives

SigninLogs
| where AppDisplayName == "OfficeHome"
| where UserPrincipalName has "@"
| summarize
    ErrorCodes=make_set(ResultType),
    RiskLevels=make_set_if(RiskLevelDuringSignIn, RiskLevelDuringSignIn != "none"),
    RiskTypes=make_set_if(RiskEventTypes, RiskEventTypes != "[]"),
    IPs = make_set(IPAddress)
    by CorrelationId, UserPrincipalName
| where ErrorCodes has_all (0, 50140, 50074) // If conditional Access Blocks the SignIn attempt change the has_all to has_all (53000, 50074)
    and RiskLevels has_any ("medium", "high") // Depending on your organisation low can be included since some AiTM attempts are only classified as low.
| extend ['Count of RiskTypes']=array_length(RiskTypes)
| where ['Count of RiskTypes'] > 0

//Advanced Hunting query, includes SessionId's 

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where Application == "OfficeHome"
| where AccountUpn has "@"
| summarize
    ErrorCodes=make_set(ErrorCode),
    RiskLevels=make_set_if(RiskLevelDuringSignIn, isnotempty(RiskLevelDuringSignIn)),
    RiskTypes=make_set_if(RiskEventTypes, isnotempty(RiskEventTypes)),
    SessionIds=make_set_if(SessionId, isnotempty(SessionId)),
    IPs = make_set_if(IPAddress, isnotempty(IPAddress))
    by CorrelationId, AccountUpn
| where ErrorCodes has_all (0, 50140, 50074) // If conditional Access Blocks the SignIn attempt change the has_all to has_all (53000, 50074)
    and RiskLevels has_any ("50", "100") // Depending on your organisation a lower risk level can be included since some AiTM attempts are only classified as low.
| extend ['Count of SessionIds']=array_length(SessionIds)
| extend ['Count of RiskTypes']=array_length(RiskTypes)
| where ['Count of SessionIds'] >= 2 and ['Count of RiskTypes'] > 0

//If you want to make a detection rule for this in Advanced Hunting you will just need to first find the suspicious correlationIds, then go back and find them so M365 Defender can map the fields properly
//Advanced Hunting needs a timestamp to create a detection. You could alternatively add a first/last event time to the query, but I prefer this way

let ids=
AADSignInEventsBeta
| where Application == "OfficeHome"
| where AccountUpn has "@"
| summarize
    ErrorCodes=make_set(ErrorCode),
    RiskLevels=make_set_if(RiskLevelDuringSignIn, isnotempty(RiskLevelDuringSignIn)),
    RiskTypes=make_set_if(RiskEventTypes, isnotempty(RiskEventTypes)),
    SessionIds=make_set_if(SessionId, isnotempty(SessionId)),
    IPs = make_set_if(IPAddress, isnotempty(IPAddress))
    by CorrelationId, AccountUpn
| where ErrorCodes has_all (0, 50140, 50074)
    and RiskLevels has_any ("50", "100")
| extend ['Count of SessionIds']=array_length(SessionIds)
| extend ['Count of RiskTypes']=array_length(RiskTypes)
| where ['Count of SessionIds'] >= 2 and ['Count of RiskTypes'] > 0
| distinct CorrelationId;
AADSignInEventsBeta
| where CorrelationId in (ids)
| summarize arg_min(Timestamp, *) by CorrelationId //grab the first event per correlationid to allow Advanced Hunting field mapping

//Detects when a user has a medium or high risk sign in requiring MFA registration (error 50079/50072) followed by successful MFA registration within 2 hours
//This may detect an adversary registering MFA on behalf of your users

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (7d)
| where RiskLevelDuringSignIn in ("medium", "high")
| where ResultType in ("50079","50072")
| project
    RiskTime=TimeGenerated,
    UserPrincipalName,
    IPAddress,
    Location,
    ResultType,
    ResultDescription
| join kind=inner(
    AuditLogs
    | where TimeGenerated > ago (7d)
    | where OperationName == "User registered security info"
    | where Result == "success"
    | extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)
    )
    on UserPrincipalName
| project-rename MFATime=TimeGenerated, MFAResult=ResultDescription1
| where (MFATime - RiskTime) between (0min .. 2h)
| extend TimeDelta=MFATime-RiskTime
| project
    RiskTime,
    MFATime,
    TimeDelta,
    UserPrincipalName,
    IPAddress,
    Location,
    ResultType,
    ResultDescription,
    MFAResult


//Detect when either application or delegated access is granted to a service principal in Azure AD

//Data connector required for this query - Azure Active Directory - Audit Logs

let delegatedaccess=
    AuditLogs
    | where OperationName has "Add delegated permission grant"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[0].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)
    | extend Activity = strcat("Delegated access added to application")
    | project
        TimeGenerated,
        Activity,
        ['Permissions granted'],
        ['Service Principal ObjectId'],
        Actor;
let appaccess=
    AuditLogs
    | where OperationName has "Add app role assignment to service principal"
    | extend x = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
    | extend ['Permissions granted'] = split(x, ' ')
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend Activity = strcat("Application access added to application")
    | extend ['Service Principal ObjectId'] = tostring(TargetResources[1].id)
    | project
        TimeGenerated,
        Activity,
        ['Permissions granted'],
        ['Service Principal ObjectId'],
        Actor;
union delegatedaccess, appaccess

//Detects when a user has a medium or high risk sign in followed by that user successfully registering MFA on another user within 4 hours
//This may detect an adversary registering MFA on behalf of your users using a compromised admin account

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Azure Active Directory - Audit Logs

SigninLogs
| where RiskLevelDuringSignIn in~ ("medium", "high")
| project
    ['Risky Signin Time']=TimeGenerated,
    UserPrincipalName,
    SigninIP=IPAddress,
    RiskLevelDuringSignIn,
    RiskEventTypes,
    SigninResult=ResultType
| join kind=inner (
    AuditLogs
    | where OperationName == "Admin registered security info" and Result == "success"
    | extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend Target = tostring(TargetResources[0].userPrincipalName)
    | project
        ['MFA Change Time']=TimeGenerated,
        OperationName,
        ResultReason,
        Actor,
        Target,
        TargetResources
    )
    on $left.UserPrincipalName == $right.Actor
| where ['MFA Change Time'] between (['Risky Signin Time'] .. timespan(4h))
| project
    ['Risky Signin Time'],
    ['MFA Change Time'],
    Actor,
    Target,
    SigninIP,
    SigninResult,
    OperationName,
    ResultReason,
    TargetResources
//Summarize sign in activity from a particular country or countries to your tenant over the last week

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query
let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
SigninLogs
| where TimeGenerated > ago(7d)
//Choose a country code, you could do multiples with | where Location in ("AU","US")
| where Location == "RU"
| extend ['Full Location'] = strcat(LocationDetails.countryOrRegion, '|', LocationDetails.state, '|', LocationDetails.city)
| where ResultType in(successCodes) or ResultType in(failureCodes)
| summarize
    ['Count of distinct successful sign ins'] = dcountif(UserPrincipalName, (ResultType in(successCodes))),
    ['List of successful users']=make_set_if(UserPrincipalName, (ResultType in(successCodes))),
    ['Successful result codes'] = make_set_if(ResultType, (ResultType in(successCodes))),
    ['Count of distinct failed sign ins'] = dcountif(UserPrincipalName, (ResultType in(failureCodes))),
    ['List of failed users'] = make_set_if(UserPrincipalName, (ResultType in(failureCodes))),
    ['Failed result codes'] = make_set_if(ResultType, (ResultType in(failureCodes)))
    by ['Full Location'], IPAddress


//Summarize Russian sign in activity to your Azure AD tenant

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

//Advanced Hunting query
let failureCodes = dynamic([50053, 50126, 50055]);
let successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);
AADSignInEventsBeta
| where Timestamp > ago(7d)
//Choose a country code, you could do multiples with | where Country in ("AU","US")
| where Country == "RU"
| extend ['Full Location'] = strcat(Country, '|', State, '|', City)
| where ErrorCode in(successCodes) or ErrorCode in(failureCodes)
| summarize
    ['Count of distinct successful sign ins'] = dcountif(AccountUpn, (ErrorCode in(successCodes))),
    ['List of successful users']=make_set_if(AccountUpn, (ErrorCode in(successCodes))),
    ['Successful result codes'] = make_set_if(ErrorCode, (ErrorCode in(successCodes))),
    ['Count of distinct failed sign ins'] = dcountif(AccountUpn, (ErrorCode in(failureCodes))),
    ['List of failed users'] = make_set_if(AccountUpn, (ErrorCode in(failureCodes))),
    ['Failed result codes'] = make_set_if(ErrorCode, (ErrorCode in(failureCodes)))
    by ['Full Location'], IPAddress
//Find Azure AD service principals that have both successful and failed sign ins because of an expired secret. For both results, find the IP addresses.

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

//If you are seeing results then the old secret is still in use somewhere and requires updating.
//Microsoft Sentinel query
AADServicePrincipalSignInLogs
| where TimeGenerated > ago(1d)
| summarize
    ['All Error Codes']=make_set(ResultType),
    ['Successful IP Addresses']=make_set_if(IPAddress, ResultType == 0),
    ['Failed IP Addresses']=make_set_if(IPAddress, ResultType == "7000222")
    by ServicePrincipalId, ServicePrincipalName
| where ['All Error Codes'] has_all ("0", "7000222")

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSpnSignInEventsBeta
| where Timestamp > ago(1d)
| summarize
    ['All Error Codes']=make_set(ErrorCode),
    ['Successful IP Addresses']=make_set_if(IPAddress, ErrorCode == 0),
    ['Failed IP Addresses']=make_set_if(IPAddress, ErrorCode == "7000222")
    by ServicePrincipalId, ServicePrincipalName
| where ['All Error Codes'] has "0" and ['All Error Codes'] has "7000222"
//Create a table of stats for your CA policies, showing which were successful, failed, not in use or applied and which are in report only mode

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| project ConditionalAccessPolicies
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend ['Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| project CAResult, ['Policy Name']
| summarize
    TotalCount=count(),
    ['Total Success Count']=countif(CAResult == "success"),
    ['Total Failure Count']=countif(CAResult == "failure"),
    ['Total Not Enabled Count']=countif(CAResult == "notEnabled"),
    ['Total Not Applied Count']=countif(CAResult == "notApplied"),
    ['Total Report Only Count']=countif(CAResult startswith "reportOnly")
    by ['Policy Name']
| extend
    ['Failure Percentage'] = round(todouble(['Total Failure Count']) * 100 / todouble(TotalCount), 2),
    ['Success Percentage'] = round(todouble(['Total Success Count']) * 100 / todouble(TotalCount), 2),
    ['Not Enabled Percentage']=round(todouble(['Total Not Enabled Count']) * 100 / todouble(TotalCount), 2),
    ['Not Applied Percentage']=round(todouble(['Total Not Applied Count']) * 100 / todouble(TotalCount), 2),
    ['Report Only Percentage']=round(todouble(['Total Report Only Count']) * 100 / todouble(TotalCount), 2)
| project-reorder
    ['Policy Name'],
    TotalCount,
    ['Total Success Count'],
    ['Success Percentage'],
    ['Total Failure Count'],
    ['Failure Percentage'],
    ['Total Not Applied Count'],
    ['Not Applied Percentage'],
    ['Total Not Enabled Count'],
    ['Not Enabled Percentage'],
    ['Total Report Only Count'],
    ['Report Only Percentage']

//Data connector required for this query - Advanced Hunting with Azure AD P2 License

AADSignInEventsBeta
| where LogonType == @"[""interactiveUser""]"
| project ConditionalAccessPolicies
| mv-expand ConditionalAccessPolicies=todynamic(ConditionalAccessPolicies)
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend ['Policy Name'] = tostring(ConditionalAccessPolicies.displayName)
| project CAResult, ['Policy Name']
| summarize
    TotalCount=count(),
    ['Total Success Count']=countif(CAResult == "success"),
    ['Total Failure Count']=countif(CAResult == "failure"),
    ['Total Not Enabled Count']=countif(CAResult == "notEnabled"),
    ['Total Not Applied Count']=countif(CAResult == "notApplied"),
    ['Total Report Only Count']=countif(CAResult startswith "reportOnly")
    by ['Policy Name']
| extend
    ['Failure Percentage'] = round(todouble(['Total Failure Count']) * 100 / todouble(TotalCount), 2),
    ['Success Percentage'] = round(todouble(['Total Success Count']) * 100 / todouble(TotalCount), 2),
    ['Not Enabled Percentage']=round(todouble(['Total Not Enabled Count']) * 100 / todouble(TotalCount), 2),
    ['Not Applied Percentage']=round(todouble(['Total Not Applied Count']) * 100 / todouble(TotalCount), 2),
    ['Report Only Percentage']=round(todouble(['Total Report Only Count']) * 100 / todouble(TotalCount), 2)
| project-reorder
    ['Policy Name'],
    TotalCount,
    ['Total Success Count'],
    ['Success Percentage'],
    ['Total Failure Count'],
    ['Failure Percentage'],
    ['Total Not Applied Count'],
    ['Not Applied Percentage'],
    ['Total Not Enabled Count'],
    ['Not Enabled Percentage'],
    ['Total Report Only Count'],
    ['Report Only Percentage']
//Find the applications that have the most privileged users accessing them using only single factor authentication

//Data connector required for this query - Azure Active Directory - Signin Logs
//Data connector required for this query - Microsoft Sentinel UEBA

let privusers=
    IdentityInfo
    | where TimeGenerated > ago(21d)
    | summarize arg_max(TimeGenerated, *) by AccountUPN
    | where isnotempty(AssignedRoles)
    | where AssignedRoles != "[]"
    | distinct AccountUPN;
SigninLogs
| where TimeGenerated > ago(30d)
| where UserPrincipalName in (privusers)
| where ResultType == 0
| where AuthenticationRequirement == "singleFactorAuthentication"
| summarize
    ['List of Users']=make_set(UserPrincipalName),
    ['Count of Users']=dcount(UserPrincipalName)
    by AppDisplayName
| sort by ['Count of Users'] desc 
//Find the top 20 IP addresses that are unknown to Azure AD, with users using unknown devices and single factor auth
//Then find the users and applications being accessed from each to help build out conditional access policy

//Data connector required for this query - Azure Active Directory - Signin Logs

let top20locations=
    SigninLogs
    | where TimeGenerated > ago(30d)
    | where ResultType == 0
    | extend DeviceTrustType = tostring(DeviceDetail.trustType)
    | where NetworkLocationDetails == '[]'
        and isempty(DeviceTrustType)
        and AuthenticationRequirement == "singleFactorAuthentication"
    | summarize Count=count()by IPAddress
    | top 20 by Count;
SigninLogs
| where ResultType == 0
| where IPAddress in (top20locations)
| summarize
    ['Total Signin Count']=count(),
    ['Distinct User Count']=dcount(UserPrincipalName),
    ['List of Users']=make_set(UserPrincipalName),
    ['Distinct Application Count']=dcount(AppDisplayName),
    ['List of Applications']=make_set(AppDisplayName)
    by IPAddress
//Summarize guest activity by external Azure AD guests (those that belong to another Azure AD tenant) vs External Guests (such as Gmail) to your tenant
//For each domain list the total number of signins and distinct user 

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (30d)
| where UserType == "Guest"
| where ResultType == 0
| extend ['Guest Domain'] = tostring(split(UserPrincipalName, "@")[1])
| summarize
    ['External Azure AD Guest Logins']=countif(ResourceTenantId != HomeTenantId),
    ['External Azure AD Guest Distinct Users']=dcountif(UserPrincipalName, ResourceTenantId != HomeTenantId),
    ['External Guest Logins']=countif(ResourceTenantId == HomeTenantId),
    ['External Guest Distinct Users']=dcountif(UserPrincipalName, ResourceTenantId == HomeTenantId)
    by ['Guest Domain']

//Alert when a user fails Azure AD Conditional Access policies to 5 or more unique applications within a short time period, this example uses 1 hour.

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago (1d)
| project TimeGenerated, ConditionalAccessPolicies, UserPrincipalName, AppDisplayName
| mv-expand ConditionalAccessPolicies
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend CAPolicyName = tostring(ConditionalAccessPolicies.displayName)
| where CAResult == "failure"
| summarize
    ['List of Failed Application']=make_set(AppDisplayName),
    ['Count of Failed Application']=dcount(AppDisplayName)
    by UserPrincipalName, bin(TimeGenerated, 1h)
| where ['Count of Failed Application'] >= 5

//Data connector required for this query - Advanced Hunting - AADSignInEventsBeta

AADSignInEventsBeta
| where Timestamp > ago (1d)
| project Timestamp, ConditionalAccessPolicies, AccountUpn, Application
| extend ConditionalAccessPolicies = parse_json(ConditionalAccessPolicies)
| extend CAResult = tostring(ConditionalAccessPolicies.result)
| extend CAPolicyName = tostring(ConditionalAccessPolicies.displayName)
| where CAResult == "failure"
| summarize
    ['List of Failed Application']=make_set(Application),
    ['Count of Failed Application']=dcount(Application)
    by AccountUpn, bin(Timestamp, 1h)
| where ['Count of Failed Application'] >= 5

//Make a set of IP addresses that your Azure AD service principals have signed in from

//Data connector required for this query - Azure Active Directory - Service Principal Signin Logs

AADServicePrincipalSignInLogs
| where TimeGenerated > ago(90d)
| where ResultType == "0"
| summarize ['List of IP Addresses']=make_set(IPAddress), ['Count of Unique IP Addresses']=dcount(IPAddress) by ServicePrincipalName, AppId
| sort by ['Count of Unique IP Addresses'] desc 
//Alert when a user is assigned to a permanent active Azure AD role

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName in ("Add member to role in PIM completed (permanent)","Add member to role in PIM completed (timebound)")
| where TargetResources[2].type == "User"
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend User = tostring(TargetResources[2].userPrincipalName)
| extend ['Azure AD Role Name'] = tostring(TargetResources[0].displayName)
| project TimeGenerated, Actor, User, ['Azure AD Role Name']

//Summarize outbound (your users connecting to other tenants) activity by listing the users and which applications they are accessing in each remote tenant

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where UserType == "Guest"
| where AADTenantId == HomeTenantId
| where ResourceTenantId != AADTenantId
| summarize
    ['Count of Applications']=dcount(AppDisplayName),
    ['List of Applications']=make_set(AppDisplayName),
    ['Count of Users']=dcount(UserPrincipalName),
    ['List of Users']=make_set(UserPrincipalName)
    by ResourceTenantId
| sort by ['Count of Users'] desc 
//Visualize distinct inbound guests (guest accounts accessing your tenant) per month

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(365d)
| where UserType == "Guest"
| where ResultType == 0
//Find only inbound guests, i.e those guests accessing your tenant.
| summarize Count=dcountif(UserPrincipalName, AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId) by startofmonth(TimeGenerated)
| render columnchart with (title="Distinct guest accounts accessing your tenant per month")
//Find the top 20 most popular applications in your tenant that have had no Conditional Access policies (success or failure) applied

//Data connector required for this query - Azure Active Directory - Signin Logs

let apps=
    SigninLogs
    | where TimeGenerated > ago (30d)
    | project TimeGenerated, ConditionalAccessPolicies, AppDisplayName
//Exclude native Microsoft apps that you can't enforce policy on or that are covered natively in Office 365
    | where AppDisplayName !in ("Microsoft Office Web Apps Service", "Microsoft App Access Panel", "Office Online Core SSO", "Microsoft Authentication Broker", "Microsoft Account Controls V2", "Microsoft 365 Support Service","Office Online Maker SSO","My Apps","My Profile")
    | mv-expand ConditionalAccessPolicies
    | extend CAResult = tostring(ConditionalAccessPolicies.result)
    | summarize ResultSet=make_set(CAResult) by AppDisplayName
    | where ResultSet !has "success" or ResultSet !has "failure"
    | project AppDisplayName;
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where AppDisplayName in (apps)
| summarize Count=count()by AppDisplayName
| top 20 by Count
//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured

//Data connector required for this query - Azure Active Directory - Signin Logs

//Microsoft Sentinel query

//Top 20 users signing into your tenant
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| summarize Count=count() by UserPrincipalName
| top 20 by Count

//Top 20 locations signing into your tenant
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| summarize Count=count() by Location
| where isnotempty(Location)
| top 20 by Count

//Top 20 users by MFA prompts
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| where AuthenticationRequirement == "multiFactorAuthentication"
| mv-expand todynamic(AuthenticationDetails)
| project TimeGenerated, AuthenticationDetails, UserPrincipalName
| extend AuthenticationMethod = tostring(AuthenticationDetails.authenticationMethod)
| where AuthenticationMethod in ("Mobile app notification","Text message","OATH verification code")
| summarize Count=count()by UserPrincipalName
| top 20 by Count

//Top 20 users by distinct applications accessed
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| summarize Count=dcount(AppDisplayName) by UserPrincipalName
| top 20 by Count

//Top 20 users accessing distinct locations accessed
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| summarize Count=dcount(Location) by UserPrincipalName
| top 20 by Count

//Top 20 applications by distinct users accessing them
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Member"
| summarize Count=dcount(UserPrincipalName) by AppDisplayName
| where AppDisplayName != "Windows Sign In"
| top 20 by Count

//Top 20 applications by distinct guests accessing them
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Guest"
| summarize Count=dcount(UserPrincipalName) by AppDisplayName
| top 20 by Count

//Top 20 guests by distinct applications accessed by them
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Guest"
| summarize Count=dcount(AppDisplayName) by UserPrincipalName
| top 20 by Count

//Top 20 guest domains accessing your tenant
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Guest"
| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
| extend ['User Domain'] = tostring(split(UserPrincipalName, "@")[1])
| summarize Count=count() by ['User Domain']
| top 20 by Count

//Top 20 guest domains accessing your tenant by distinct applications accessed
SigninLogs
| where TimeGenerated > ago (30d)
| where ResultType == 0
| where UserType == "Guest"
| where AADTenantId != HomeTenantId and HomeTenantId != ResourceTenantId
| extend ['User Domain'] = tostring(split(UserPrincipalName, "@")[1])
| summarize Count=dcount(AppDisplayName) by ['User Domain']
| top 20 by Count
//Find when a new Azure AD tenant is created by a user in your tenant

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName == "Create Company"
| where Result == "success"
| extend Type = tostring(TargetResources[0].type)
| where Type == "Directory"
| extend ['Actor IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['New Tenant Id'] = tostring(TargetResources[0].id)
| project TimeGenerated, OperationName, Actor, ['Actor IP Address'], ['New Tenant Id']
//Alert when a user is added directly to an Azure AD role, bypassing PIM

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where OperationName has "Add member to role outside of PIM"
| extend RoleName = tostring(TargetResources[0].displayName)
| extend UserAdded = tostring(TargetResources[2].displayName)
| extend Actor = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| project TimeGenerated, OperationName, RoleName, UserAdded, Actor
//Create a daily summary of Azure Active Directory group additions

//Data connector required for this query - Azure Active Directory - Audit Logs

let timerange=7d;
AuditLogs
| where TimeGenerated > ago (timerange)
| where OperationName == "Add member to group"
| extend Type = tostring(TargetResources[0].type)
| where Type == "User"
| extend ['Group Name'] = tostring(parse_json(tostring(parse_json(tostring(TargetResources[0].modifiedProperties))[1].newValue)))
| extend UserAdded = tostring(TargetResources[0].userPrincipalName)
| where isnotempty(UserAdded)
| summarize ['Users Added']=make_set(UserAdded) by ['Group Name'], startofday(TimeGenerated)
| sort by ['Group Name'] asc, TimeGenerated desc 
//Find users who have failed 3 or more times to set a new password during a SSPR flow. Worth reaching out to them to give them a hand or see if you can onboard them to something like Windows Hello for Business

//Data connector required for this query - Azure Active Directory - Audit Logs

AuditLogs
| where LoggedByService == "Self-service Password Management"
| extend User = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
| extend ['User IP Address'] = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)
| sort by TimeGenerated asc 
| summarize ['SSPR Actions']=make_list_if(ResultReason, ResultReason has "User submitted a new password") by CorrelationId, User, ['User IP Address']
| where array_length(['SSPR Actions']) >= 3
| sort by User desc 

//Visualize sign in attempts to your Azure AD tenant by known or unknown network locations

//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
//If a location it will be populated by its name, i.e 'Corporate Internet', if known the NetworkLocationDetails array is empty so we can find it by searching on '[]'
| summarize
    ['Known Location']=countif(NetworkLocationDetails != '[]'),
    ['Unknown Location']=countif(NetworkLocationDetails == '[]')
    by bin (TimeGenerated, 1d)
| render timechart with (title="Known vs Unknown signins to Azure AD", ytitle="Count")

//Detect when a user retrieves keys for Azure storage for the first time compared to the previous time range

//Data connector required for this query - Azure Activity 

let knownusers=
    AzureActivity
    | where TimeGenerated > ago(90d) and TimeGenerated < ago(1d)
    | where OperationName == "List Storage Account Keys"
    | where ActivityStatus == "Succeeded"
    | project-rename Actor=Caller
    | distinct Actor;
AzureActivity
| where TimeGenerated > ago(1d)
| where OperationName == "List Storage Account Keys"
| where ActivityStatus == "Succeeded"
| project-rename Actor=Caller
| where Actor !in (knownusers)
| project
    TimeGenerated,
    Actor,
    ['Actor IP Address']=CallerIpAddress,
    ['Storage Account Name']=Resource,
    ['Azure Subscription Id']=SubscriptionId,
    ['Azure Resource Group']=ResourceGroup 
//Detect when the workspace keys to an Azure log analytics workspace are read

//Data connector required for this query - Azure Activity 

AzureActivity
| where OperationNameValue == "MICROSOFT.OPERATIONALINSIGHTS/WORKSPACES/SHAREDKEYS/ACTION"
| extend WorkspaceName = tostring(parse_json(Properties).resource)
| where ActivityStatusValue == "Success"
| project
    TimeGenerated,
    Actor=Caller,
    ['Log Analytics Workspace Name']=WorkspaceName,
    ['Actor IP Address']=CallerIpAddress,
    ['Azure Subscription Id']=SubscriptionId,
    ['Azure Resource Group']=ResourceGroup
//Detect when an Azure AD service principal is given access to an Azure RBAC scope, i.e contributor to a subscription or resource group

//Data connector required for this query - Azure Activity 

AzureActivity
| where OperationNameValue == "MICROSOFT.AUTHORIZATION/ROLEASSIGNMENTS/WRITE"
| extend ServicePrincipalObjectId = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalId)
| extend ServicePrincipalType = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).PrincipalType)
| extend Scope = tostring(parse_json(tostring(parse_json(tostring(Properties_d.requestbody)).Properties)).Scope)
| extend RoleAdded = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).RoleDefinitionId)
| extend Actor = tostring(Properties_d.caller)
| where ServicePrincipalType == "ServicePrincipal"
| project TimeGenerated, RoleAdded, Scope, ServicePrincipalObjectId, Actor
//Detect when a resource lock is added or removed from an Azure resource

//Data connector required for this query - Azure Activity 

AzureActivity
| where OperationNameValue in ("MICROSOFT.AUTHORIZATION/LOCKS/WRITE", "MICROSOFT.AUTHORIZATION/LOCKS/DELETE")
| where ActivityStatusValue == "Success"
| extend Activity = case(OperationNameValue == "MICROSOFT.AUTHORIZATION/LOCKS/WRITE", strcat("Resource Lock Added"),
    OperationNameValue == "MICROSOFT.AUTHORIZATION/LOCKS/DELETE", strcat("Resource Lock Removed"),
    "unknown")
| extend ResourceGroup = tostring(parse_json(Properties).resourceGroup)
| extend AzureResource = tostring(parse_json(Properties).resourceProviderValue)
| extend x = tostring(parse_json(Properties).resource)
| parse x with ResourceName "/" *
| parse x with * "microsoft.authorization/" LockName
| project
    TimeGenerated,
    Activity,
    ResourceName,
    ['Azure Resource']=AzureResource,
    ['Azure Subscription Id']=SubscriptionId,
    ['Azure Resource Group']=ResourceGroup,
    LockName
//Alerts on users being added to roles on your Azure Sentinel log analytics workspace.

//Data connector required for this query - Azure Activity 
//Data connector required for this query - Microsoft Sentinel UEBA

//Uses a lookup to a GitHub gist to match Azure role ids to friendly role names and the IdentityInfo to retrieve identity details

let workspaceid="your Sentinel workspace id";
let timeframe=1d;
let AZRoles = externaldata(Name: string, Id: string) [@"https://gist.githubusercontent.com/reprise99/363eee70938c9a3d662e3f6da4610fe4/raw/b25b2d7a626396684ab578363888a0e360e7b287/.csv"] with(ignoreFirstRecord=true, format="csv");
let accesschange =AzureActivity
    | where TimeGenerated > ago(timeframe)
    | where OperationName == "Create role assignment"
    | where TenantId == workspaceid
    | extend TargetAADUserId = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).PrincipalId)
    | extend RoleDefinitionId = tostring(parse_json(tostring(parse_json(tostring(parse_json(Properties).requestbody)).Properties)).RoleDefinitionId)
    | parse RoleDefinitionId with * '/roleDefinitions/' AzureRoleId
    | where ActivityStatus == "Started"
    | project
        AccessChangeTime=TimeGenerated,
        Actor=Caller,
        ActorIPAddress=CallerIpAddress,
        ResourceGroup,
        WorkspaceId=TenantId,
        AzureRoleId,
        TargetAADUserId
    | join kind=inner (AZRoles 
        )
        on $left.AzureRoleId == $right.Id
    | project-away Id;
IdentityInfo
| where TimeGenerated > ago(21d)
| summarize arg_max(TimeGenerated, *) by AccountUPN
| join kind=inner accesschange on $left.AccountObjectId == $right.TargetAADUserId
| project
    AccessChangeTime=TimeGenerated,
    Actor,
    ActorIPAddress,
    ResourceGroup,
    WorkspaceId=TenantId,
    AzureRoleId,
    AzureRoleName=Name,
    TargetAADUserId,
    AccountUPN
//Detect when a download URL is generated for an Azure virtual machine disk

//Data connector required for this query - Azure Activity 

AzureActivity
| where OperationNameValue == "MICROSOFT.COMPUTE/DISKS/BEGINGETACCESS/ACTION"
| where ActivityStatusValue == "Success"
| extend DiskName = tostring(Properties_d.resource)
| project
    TimeGenerated,
    Actor=Caller,
    ['Actor IP Address']=CallerIpAddress,
    ['Azure Subscription Id']=SubscriptionId,
    ['Azure Resource Group']=ResourceGroup,
    DiskName

//Visualize downloads from your Office 365 tenant by trust type (trusted/known by Azure Active Directory vs Unknown)

//Data connector required for this query - Office 365
//Data connector required for this query - Azure Active Directory - Signin Logs

//Query Azure AD logs to get a listing of each username, IPAddress and trust type
SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where UserType == "Member"
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| distinct UserPrincipalName, IPAddress, DeviceTrustType
//Join to Office Activity download on username and IP and find download events
| join kind=inner(
    OfficeActivity
    | where TimeGenerated > ago(30d)
    | where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
    )
    on $left.UserPrincipalName == $right.UserId, $left.IPAddress == $right.ClientIP
//Summarize download events by whether the device is known or not
| summarize
    ['Trusted Devices']=countif(isnotempty(DeviceTrustType)),
    ['Untrusted Devices']=countif(isempty(DeviceTrustType))
    by bin(TimeGenerated, 1d)
| render timechart with (title="Downloads from Office 365 by device trust type")

//When Office 365 detects malware in OneDrive or SharePoint find any users that downloaded the same file

//Data connector required for this query - Office 365

let malware=
    OfficeActivity
    | where TimeGenerated > ago(1d)
    | where Operation == "FileMalwareDetected"
    | distinct OfficeObjectId;
OfficeActivity
| where TimeGenerated > ago (1d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where OfficeObjectId in (malware)
| summarize ['Users who Downloaded']=make_set(UserId) by ['File Name']=OfficeObjectId
//Detect anomalies in the amount of files shared to guests in your Office 365 tenant from your users.

//Data connector required for this query - Office 365

//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.
let startdate=21d;
let enddate=1d;
//Timeframe = time period to break the data up into, i.e 1 hour blocks.
let timeframe=1h;
//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5
let sensitivity=2;
//Threshold = set a threshold to account for low volume anomailies, i.e moving from 1 file shared to 2 within an hour
let threshold = 5;
let outlierusers=
OfficeActivity
| where Operation in ("AddedToSecureLink","SecureLinkCreated","SecureLinkUpdated")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#ext#"
| make-series GuestFileShares=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId
| extend outliers=series_decompose_anomalies(GuestFileShares, sensitivity)
| mv-expand TimeGenerated, GuestFileShares, outliers
| where outliers == 1 and GuestFileShares > threshold
//Optionally visualize the anomalies - remove everything below this line to just retrieve the data instead of visualizing
| distinct UserId;
OfficeActivity
| where Operation in ("AddedToSecureLink","SecureLinkCreated","SecureLinkUpdated")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#ext#"
| where UserId in (outlierusers)
| make-series GuestFileShares=count() default=0 on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId 
| render timechart with (ytitle="Share Count",title="Anomalous Files Shared to Guests")
//Visualize the files shared to guests from Office 365 over time

//Data connector required for this query - Office 365

let timerange=90d;
OfficeActivity
| where TimeGenerated > ago(timerange)
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| where TargetUserOrGroupType == "Guest"
| summarize Count=count()by bin(TimeGenerated, 1d)
| render timechart with (ytitle="File Count", title="Files shared with guests over time")
//Find the top 20 of a collection of varied data sets, no real detections in here just interesting data that is captured

//Data connector required for this query - Office 365

//Top 20 files downloaded from your tenant
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| summarize Count=count()by OfficeObjectId
| top 20 by Count

//Top 20 users downloading files from your tenant
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId !contains "#EXT#"
| summarize Count=count()by UserId
| top 20 by Count

//Top 20 guests downloading files from your tenant
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
| extend ['Guest UserPrincipalName'] = tostring(split(UserId,"#")[0])
| summarize Count=count()by ['Guest UserPrincipalName']
| top 20 by Count

//Top 20 downloads from your tenant by guest domain
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
| extend ['Guest UserPrincipalName'] = tostring(split(UserId,"#")[0])
| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'],"_")[-1])
| summarize Count=count()by ['Guest Domain']
| top 20 by Count

//Top 20 users sharing files to guests
OfficeActivity
| where TimeGenerated > ago(30d)
| where OfficeWorkload == "OneDrive"
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#EXT#"
| summarize Count=count() by UserId
| top 20 by Count

//Top 20 most shared files
OfficeActivity
| where TimeGenerated > ago(30d)
| where OfficeWorkload == "OneDrive"
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| summarize Count=count() by OfficeObjectId
| top 20 by Count

//Top 20 guests with files shared to them
OfficeActivity
| where TimeGenerated > ago(30d)
| where OfficeWorkload == "OneDrive"
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#EXT#"
| summarize Count=count() by TargetUserOrGroupName
| top 20 by Count

//Top 20 guests added to Teams by distinct Team name
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation == "MemberAdded"
| mv-expand Members
| extend UserAdded = tostring(Members.UPN)
| where UserAdded contains "#EXT#"
| where CommunicationType == "Team"
| where UserId != "Microsoft Teams Sync"
| summarize Count=dcount(TeamName) by UserId
| top 20 by Count

//Visualize any post delivery actions such as email being quarantined or deleted by admins

//Data connector required for this query - M365 Defender - Email* tables

EmailPostDeliveryEvents
| where TimeGenerated > ago (90d)
| where Action !in ("None", "Unknown")
| make-series Count=count() on TimeGenerated from ago(45d) to now() step 1d by Action
| render timechart with (title="Email post delivery actions over time")
//Visualize uploads vs downloads in your Office 365 tenant per day

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| project TimeGenerated, Operation
| where Operation in ("FileSyncDownloadedFull", "FileSyncUploadedFull", "FileDownloaded", "FileUploaded")
| summarize
    ['Files Downloaded']=countif(Operation in ("FileDownloaded", "FileSyncDownloadedFull")),
    ['Files Uploaded']=countif(Operation in ("FileSyncUploadedFull", "FileUploaded"))
    by startofday(TimeGenerated)
| render columnchart
    with (
    kind=unstacked,
    title="Downloads vs Uploads in Office 365",
    ytitle="Count",
    xtitle="Day")
//Visualize the guest domains that have had the most files shares to them from your Office 365 tenant

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in~ ("AddedToSecureLink", "SecureLinkCreated", "SecureLinkUpdated")
| where TargetUserOrGroupType == "Guest" and TargetUserOrGroupName contains "#ext#"
| extend ['Guest UserPrincipalName'] = tostring(split(TargetUserOrGroupName, "#")[0])
| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'], "_")[-1])
| summarize Count=count() by ['Guest Domain']
| top 20 by Count
| render barchart with (title="Top guest domains with files shared to")
//Find any of your Teams that have had guests added to them in the last week and arrange by the Teams with the most guests added.

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(7d)
| where Operation == "MemberAdded"
| mv-expand Members
| extend UserAdded = tostring(Members.UPN)
| where UserAdded contains "#EXT#"
| where CommunicationType == "Team"
| summarize
    ['Number of Guests Added']=dcount(UserAdded),
    ['List of Guests Added']=make_set(UserAdded)
    by TeamName
| sort by ['Number of Guests Added'] desc 
//Visualize the deviation of email being blocked to your Office 365 tenant per day
//Query adapted from https://github.com/samikroy/kql-store/blob/main/Deviation%20in%20Security%20Events.md

//Data connector required for this query - M365 Defender - Email* tables

//Find the average blocked email per day
let AverageBlockedEmail = toscalar(EmailEvents
| where TimeGenerated > ago(250d)
| where DeliveryAction == "Blocked"
| summarize Count=count() by bin(TimeGenerated, 1d)
| summarize avg(Count));
//Find the total count of blocked email per day
EmailEvents
| where TimeGenerated > ago(250d)
| where DeliveryAction == "Blocked"
| summarize Count=count() by bin(TimeGenerated, 1d)
| extend Deviation = (Count - AverageBlockedEmail) / AverageBlockedEmail
| project-away Count
//Visualize the deviation per day
| render columnchart with (title="Deviation of email blocked per day")
//When a malicious email is received, list all the users who received it and all the users who read it

//Data connector required for this query - M365 Defender - Email* tables
//Data connector required for this query - Office 365

//First find all the users who received the email
EmailEvents
| where EmailDirection == "Inbound"
//Add in your malicious subject or malicious sender address
| where Subject == "Malicious Subject Name" or SenderFromAddress == "malicioususer@domain.com"
| project RecipientEmailAddress, Subject, InternetMessageId, SenderFromAddress
//Combine that data with the OfficeActivity table which tracks whether an email was accessed
| join kind=inner (
    OfficeActivity
    | where Operation == "MailItemsAccessed"
    | mv-expand todynamic(Folders)
    | extend FolderItems = Folders.FolderItems
    | mv-expand FolderItems
    | extend InternetMessageId = tostring(FolderItems.InternetMessageId)
    | project UserId, InternetMessageId
    )
    on InternetMessageId
//Create summary of data listing the count and all the users who received the email vs the list and count of those that read it
| summarize
    ['Receipient Count']=dcount(RecipientEmailAddress),
    ['Users Who Received Email']=make_set(RecipientEmailAddress),
    ['Reader Count']=dcount(UserId),
    ['Users Who Read Email']=make_set(UserId)
    by SenderFromAddress, Subject, InternetMessageId
//Calculate the time Office 365 took to detect malware after the file was uploaded

//Data connector required for this query - Office 365

//First find the malware detection event
OfficeActivity
| where TimeGenerated > ago(60d)
| where Operation == "FileMalwareDetected"
| project
    DetectionTime=TimeGenerated,
    OfficeWorkload,
    ['File Name']=SourceFileName,
    ['File Location']=OfficeObjectId
//Then join back to the upload event on the same file location
| join kind=inner 
    (
    OfficeActivity
    | where TimeGenerated > ago (60d)
    | where Operation in ("FileUploaded", "FileSyncUploadedFull")
    | project
        UploadTime=TimeGenerated,
        OfficeWorkload,
        ['File Name']=SourceFileName,
        ['File Location']=OfficeObjectId,
        ['Relative File URL']=SourceRelativeUrl
    | summarize min(UploadTime) by ['File Location'], UploadTime
    )
    on ['File Location']
//Calculate the time difference between upload and malware detection
| project
    ['File Name'],
    UploadTime,
    DetectionTime,
    ['Time Difference in Minutes']=datetime_diff("minute", DetectionTime, UploadTime),
    ['File Location']
//Visualize the top 20 files downloaded by Azure AD guests over the last month

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago (30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#ext#"
| summarize Count=count()by FileName=SourceFileName
| sort by Count desc
| take 20
| render barchart with (title="Top files downloaded by guests over the last month")
//Find when files are shared from OneDrive to third party guests

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(7d)
| where OfficeWorkload == "OneDrive"
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#EXT#"
| project
    TimeGenerated,
    ['User Who Shared']=UserId,
    ['Guest Granted Access']=TargetUserOrGroupName,
    ['File Shared']=OfficeObjectId
| sort by TimeGenerated desc 
//Create a set of users external to your organization who have accessed Office files after being shared. Events are grouped by the user who shared the document, and what activities were performed against it and by which external account.

//Data connector required for this query - Office 365

OfficeActivity
| project LinkCreatedTime=TimeGenerated, Operation, UserWhoShared=UserId, OfficeObjectId
| where Operation in ('AddedToSecureLink', 'SecureLinkCreated', 'SecureLinkUpdated', 'SharingInvitationCreated')
| join kind=inner
    (OfficeActivity
    | project LinkClickedTime=TimeGenerated, Operation, UserWhoAccessed=UserId, OfficeObjectId)
    on OfficeObjectId
| where UserWhoAccessed !endswith "yourdomain.com" and UserWhoAccessed != "app@sharepoint"
| extend ExternalOperation=Operation1
| summarize ExternalUsers=make_set(UserWhoAccessed) by UserWhoShared, OfficeObjectId, ExternalOperation
//Summarize the applications installed into Teams in the last month. Apps are grouped into the scope they were installed to - Team, Chat or User and by name and application id

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago (30d)
| where Operation == "AppInstalled"
| summarize
    ['App Installed to Team Scope']=countif(OperationScope == "Team"),
    ['App Installed to Chat Scope']=countif(OperationScope == "Chat"),
    ['App Installed to User Scope']=countif(OperationScope == "User")
    by AddonName, AzureADAppId
| sort by AddonName asc  
//Visualize the most blocked domains sending email inbound to your users

//Data connector required for this query - M365 Defender - Email* tables

//Microsoft Sentinel query
EmailEvents
| where TimeGenerated > ago (7d)
| where EmailDirection == "Inbound"
| where DeliveryAction == "Blocked"
| extend Domain = tostring(split(SenderMailFromAddress, "@")[-1])
| summarize BlockedCount=count()by Domain
| where isnotempty(Domain)
| sort by BlockedCount desc
| render barchart 

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting license

EmailEvents
| where Timestamp > ago (7d)
| where EmailDirection == "Inbound"
| where DeliveryAction == "Blocked"
| extend Domain = tostring(split(SenderMailFromAddress, "@")[-1])
| summarize BlockedCount=count()by Domain
| where isnotempty(Domain)
| sort by BlockedCount desc
| render barchart 
//Create a daily summary of activities completed by your O365 admins

//Data connector required for this query - Office 365
//Data connector required for this query - Microsoft Sentinel UEBA

let timerange=14d;
IdentityInfo
| where TimeGenerated > ago(21d)
| summarize arg_max(TimeGenerated, *) by AccountUPN
| where AssignedRoles has_any ("Global Administrator", "Exchange Administrator", "Teams Administrator", "SharePoint Administrator")
| project UserId=AccountUPN
| join kind=inner (
    OfficeActivity
    | where TimeGenerated > ago(timerange)
    )
    on UserId
| summarize AdminActivities=make_list(Operation)by UserId, startofday(TimeGenerated)
// Finds guest accounts who were added to a Team and then downloaded documents straight away. 

//Data connector required for this query - Office 365

// Startime = Amount of time to look back on, i.e last 7 days.
// Timeframe = looks for downloads for this period after being added to the Team, i.e 2 hours after being added.
let starttime = 7d;
let timeframe = 2h;
let operations = dynamic(["FileSyncDownloadedFull", "FileDownloaded"]);
OfficeActivity
| where TimeGenerated > ago(starttime)
| where Operation == "MemberAdded"
| mv-expand Members
| extend UserAdded = tostring(Members.UPN)
| where UserAdded contains "#EXT#"
| where CommunicationType == "Team"
| project TimeAdded=TimeGenerated, UserId=tolower(UserAdded)
| join kind=inner
    (
    OfficeActivity
    | where TimeGenerated > ago(starttime)
    | where Operation in (['operations'])
    )
    on UserId
| project DownloadTime=TimeGenerated, TimeAdded, FileName=SourceFileName, UserId
| where (DownloadTime - TimeAdded) between (0min .. timeframe)
//Optionally summarize the data into the activity by each guest
| summarize
    ['Count of Files Downloaded']=count(),
    ['List of Files Downloaded']=make_set(FileName)
    by UserId
| sort by ['Count of Files Downloaded'] desc 
//Find any new operations audited in Office 365 in the last 14 days vs the previous 180 days

//Data connector required for this query - Office 365

let existingoperations=
    OfficeActivity
    | where TimeGenerated > ago(180d) and TimeGenerated < ago(14d)
    | distinct Operation;
OfficeActivity
| where TimeGenerated > ago(14d)
| summarize arg_min(TimeGenerated, *) by Operation
| where Operation !in (existingoperations)
| project ['Time First Seen']=TimeGenerated, Operation, OfficeWorkload
//Alerts when a file believed to be malware is uploaded to your Office 365 tenant in SharePoint or OneDrive

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation == "FileMalwareDetected"
| project
    TimeGenerated,
    OfficeWorkload,
    ['File Name']=SourceFileName,
    ['File Location']=OfficeObjectId,
    ['Relative File URL']=SourceRelativeUrl,
    ClientIP

//When a macro is received via email from an external sender, find all users who receieved the same file

//Data connector required for this query - M365 Defender - Email* tables

//Microsoft Sentinel query
EmailEvents
| where EmailDirection == "Inbound"
| project
    TimeGenerated,
    SenderMailFromAddress,
    RecipientEmailAddress,
    NetworkMessageId
| join kind=inner (EmailAttachmentInfo) on NetworkMessageId
| project
    TimeGenerated,
    SenderMailFromAddress,
    RecipientEmailAddress,
    FileName
| where FileName endswith ".xlsm" or FileName endswith ".xstm"
| summarize Recipient=make_set(RecipientEmailAddress) by FileName, SenderMailFromAddress

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting license

EmailEvents
| where EmailDirection == "Inbound"
| project
    Timestamp,
    SenderMailFromAddress,
    RecipientEmailAddress,
    NetworkMessageId
| join kind=inner (EmailAttachmentInfo) on NetworkMessageId
| project
    Timestamp,
    SenderMailFromAddress,
    RecipientEmailAddress,
    FileName
| where FileName endswith ".xlsm" or FileName endswith ".xstm"
| summarize Recipient=make_set(RecipientEmailAddress) by FileName, SenderMailFromAddress
//Summarize the total count of downloads from Office 365 for each of your guest domains

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
| extend ['Guest UserPrincipalName'] = tostring(split(UserId,"#")[0])
| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'],"_")[-1])
| project ['Guest Domain']
| summarize ['Download Count']=count()by ['Guest Domain']
| sort by ['Download Count'] desc 
//Create a weekly summary of Teams created and deleted in your Office 365 tenant

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("TeamCreated", "TeamDeleted")
| summarize
    ['Count of Teams Created']=dcountif(TeamName, Operation == "TeamCreated"),
    ['List of Teams Created']=make_set_if(TeamName, Operation == "TeamCreated"),
    ['Count of Teams Deleted']=dcountif(TeamName, Operation == "TeamDeleted"),
    ['List of Teams Deleted']=make_set_if(TeamName, Operation == "TeamDeleted")
    by Week=startofweek(TimeGenerated)
| sort by Week desc 
//Query to retrieve the name of inbox rules created via mv-apply

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago (30d)
| where Operation == "New-InboxRule"
| mv-apply p=todynamic(Parameters) on (
where p.Name == "Name"
| extend RuleName = tostring(p.Value)
)
| project TimeGenerated, UserId, ClientIP, RuleName
//Additionally search for inbox rule names that have no alphanumeric characters, can be a sign of threat actor activity
| where RuleName matches regex @"^[^a-zA-Z0-9]*$"
//Detects users with global or exchange administrator roles who have accessed email items from mailboxes other than their own

//Data connector required for this query - Office 365
//Data connector required for this query - Microsoft Sentinel UEBA

let timeframe=30d;
let adminusers=
IdentityInfo
| where TimeGenerated > ago(21d)
| where AssignedRoles has_any ("Exchange Administrator", "Global Administrator")
| summarize arg_max(TimeGenerated, *) by AccountUPN
| project UserId=AccountUPN;
OfficeActivity
| where TimeGenerated > ago(timeframe)
| where OfficeWorkload == "Exchange"
| where Operation == "MailItemsAccessed"
| where UserId in (adminusers)
| where UserId != MailboxOwnerUPN
| project AccessTime=TimeGenerated, UserId, MailboxOwnerUPN, Folders
//Detect when a user is made an owner on multiple Teams in a short time frame.

//Data connector required for this query - Office 365

//Define a time period to check and the threshold of how many Teams to alert on.
//This example would find users added as an owner to 3 or more Teams within 30 minutes.
let timeframe=30m;
let threshold=3;
OfficeActivity
| where TimeGenerated > ago(1d)
| where Operation == "MemberRoleChanged"
| mv-expand Members
| extend RoleAdded = tostring(Members.Role)
| extend UserAdded = tostring(Members.UPN)
| where RoleAdded == 2
| project TimeGenerated, RoleAdded, UserAdded, TeamName
| summarize
    ['Number of Teams Made Owner']=dcount(TeamName), ['Team Names']=make_set(TeamName) by UserAdded, bin(TimeGenerated, timeframe)
| where ['Number of Teams Made Owner'] >= threshold
//Visualises potentially anomalous download activities in your Office tenant over the set period. Time frames can be adjusted to suit. 

//Data connector required for this query - Office 365

//Starttime and timeframe = how many days of data to look at and in what grouping, i.e 7 days of data over 1 hour periods.
//Threshold = the amount of total downloads required to be included in anomaly calculations. Reduces noise from low level anomalies, e.g going from 1 download to 3 downloads total.
//sensitivity = adjust to make the query more or less sensitive, the higher the value, the greater the anomaly required to be detected.
let starttime = 7d;
let timeframe = 1h;
let threshold = 30;
let sensitivity = 2;
let operations = dynamic(["FileSyncDownloadedFull","FileDownloaded"]);
let outlierusers=
OfficeActivity
| where TimeGenerated > ago(starttime)
| where Operation in (['operations'])
| project TimeGenerated, UserId
| order by TimeGenerated
| summarize Events=count()by UserId, bin(TimeGenerated, timeframe)
| where Events > threshold
| summarize EventCount=make_list(Events),TimeGenerated=make_list(TimeGenerated) by UserId
| extend outliers=series_decompose_anomalies(EventCount,sensitivity)
| mv-expand TimeGenerated, EventCount, outliers
| where outliers == 1
| distinct UserId;
OfficeActivity
| where TimeGenerated > ago(starttime)
| where Operation in (['operations'])
| where UserId in (outlierusers)
| summarize DownloadCount=count()by UserId, bin(TimeGenerated, timeframe)
| render timechart
//Detect anomalies in the amount of downloads from your Office 365 tenant by guest accounts.

//Data connector required for this query - Office 365

//Starttime and endtime = which period of data to look at, i.e from 21 days ago until today.
let startdate=21d;
let enddate=1d;
//Timeframe = time period to break the data up into, i.e 1 hour blocks.
let timeframe=1h;
//Sensitivity = the lower the number the more sensitive the anomaly detection is, i.e it will find more anomalies, default is 1.5
let sensitivity=2;
//Threshold = set this to tune out low count anomalies, i.e when total downloads are only over 300 per hour
let threshold=300;
let outlierusers=
OfficeActivity
| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))
| where Operation in ("FileSyncDownloadedFull","FileDownloaded")
| where UserId contains "#EXT#"
| make-series GuestDownloads=count() on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId
| extend outliers=series_decompose_anomalies(GuestDownloads, sensitivity)
| mv-expand TimeGenerated, GuestDownloads, outliers
| where outliers == 1 and GuestDownloads > threshold
//Optionally visualize the anomalies - remove everything below this line to just retrieve the data instead of visualizing
| distinct UserId;
OfficeActivity
| where TimeGenerated between (startofday(ago(startdate))..startofday(ago(enddate)))
| where Operation in ("FileSyncDownloadedFull","FileDownloaded")
| where UserId contains "#EXT#"
| where UserId in (outlierusers)
| make-series GuestDownloads=count() default=0 on TimeGenerated from startofday(ago(startdate)) to startofday(ago(enddate)) step timeframe by UserId 
| render timechart with (ytitle="Download Count",title="Anomalous Guest Downloads from Office 365")
//When Defender for Cloud detects a possible DNS lookup to a phishing domain attempt to find if the URL was part of an email phishing attack

//Data connector required for this query - M365 Defender - Email* tables
//Data connector required for this query - Security Alert (free table that other Defender products send alert info to)

let suspiciousdomains=
    SecurityAlert
    | where AlertName startswith "Communication with possible phishing domain"
    | mv-expand todynamic(Entities)
    | extend DomainName = tostring(Entities.DomainName)
    | where isnotempty(DomainName)
    | distinct DomainName;
EmailEvents
| where EmailDirection == "Inbound"
| project
    TimeGenerated,
    SenderMailFromAddress,
    RecipientEmailAddress,
    EmailDirection,
    NetworkMessageId
| join kind=inner (EmailUrlInfo) on NetworkMessageId
| project
    TimeGenerated,
    SenderMailFromAddress,
    RecipientEmailAddress,
    EmailDirection,
    Url,
    UrlDomain
| where UrlDomain in~ (suspiciousdomains)
//Find the top 20 guests who are downloading files from your tenant and calculate the percentage of total downloads from those users. Useful to see if you have a few guests responsible for most of the downloads in your tenant.

//Data connector required for this query - Office 365

//First find the count of all downloads by guests in your tenant
let totalguestdownloads=
    OfficeActivity
    | where TimeGenerated > ago(30d)
    | where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
    | where UserId contains "#EXT#"
    | count
//Extend a fake column we will use to join our two queries
    | extend ['Total Download Count'] = Count, Constant="x";
OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
//Extend the same fake column to use to join our two queries
| extend Constant="x"
| extend ['Guest UserPrincipalName'] = tostring(split(UserId, "#")[0])
//Summarize download count by each guest and join to our first query
| summarize ['Individual Download Count']=count()by ['Guest UserPrincipalName'], Constant
| join kind=fullouter totalguestdownloads on Constant
| project-away Constant, Constant1, Count
| sort by ['Individual Download Count'] desc 
//Take the top 20 and then calculate the percentage
| take 20
| extend ['Percentage of Total Downloads']=(todouble(['Individual Download Count']) * 100 / todouble(['Total Download Count']))
//Visualize how much is email is being blocked as a percentage of total email over time

//Data connector required for this query - M365 Defender - Email* tables

EmailEvents
| where TimeGenerated > ago (30d)
| where EmailDirection == "Inbound"
| summarize
    TotalCount=count(),
    BlockedCount=countif(DeliveryAction in ("Blocked", "Junked"))
    by bin(TimeGenerated, 6h)
| extend Percentage=(todouble(BlockedCount) * 100 / todouble(TotalCount))
| project-away TotalCount, BlockedCount
| render timechart with (title="Percentage of email blocked over time", ymax=100)
//Visualize inbound email actions (Delivered, Junked, Blocked) per day over time

//Data connector required for this query - M365 Defender - Email* tables

//Microsoft Sentinel query
EmailEvents
| where TimeGenerated > ago (90d)
| where EmailDirection == "Inbound"
| summarize Count=count()by DeliveryAction, bin(TimeGenerated, 1d)
| render columnchart with (kind=unstacked, title="Email delivery actions over time")

//Advanced Hunting query. Advanced hunting only retains 30 days data, so to show a similar visualization, we can slice the vents up into 6 hour blocks

//Data connector required for this query - Advanced Hunting license

EmailEvents
| where Timestamp > ago (30d)
| where EmailDirection == "Inbound"
| summarize count()by DeliveryAction, bin(Timestamp, 6h)
//Advanced hunting cannot visualize column charts as well as Sentinel so rendering as a timechart produces a better result
| render timechart  
//Visualize guests added vs removed from Teams per day over the last 30 days

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where UserType == "Regular"
| where CommunicationType == "Team"
| where OfficeWorkload == "MicrosoftTeams" 
| where Operation in ("MemberAdded", "MemberRemoved")
| mv-expand Members
| extend User = tostring(Members.UPN)
| where User contains "#EXT#"
| project TimeGenerated, Operation, User
| summarize
    ['Guests Added']=countif(Operation == "MemberAdded"),
    ['Guests Removed']=countif(Operation == "MemberRemoved")
    by startofday(TimeGenerated)
| render columnchart
    with (
    kind=unstacked,
    xtitle="Count",
    ytitle="Day",
    title="Guests Added vs Removed from Teams")
//Visualize total guests redeemed in Azure AD vs guests that have been added to a Team

//Data connector required for this query - Office 365

let guestsredeemed=
    AuditLogs
    | where TimeGenerated > ago (90d)
    | where OperationName == "Redeem external user invite"
    | extend GuestRedeemed = tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)
    | extend Activity = strcat("Guest Invite Redeemed")
    | project TimeGenerated, GuestRedeemed, Activity;
let guestsaddedtoteams=
    OfficeActivity
    | where TimeGenerated > ago(90d)
    | where Operation == "MemberAdded"
    | mv-expand Members
    | extend GuestAdded = tostring(Members.UPN)
    | where GuestAdded contains "#EXT#"
    | extend Activity = strcat("Guest Added to Team")
    | project TimeGenerated, GuestAdded, Activity;
union guestsredeemed, guestsaddedtoteams
| summarize ['Total Count']=count() by Activity, bin(TimeGenerated, 1d)
| render columnchart with (kind=unstacked, title="Total Guests Redeemed vs Guests Added to Teams")
//Find the top 20 users who are downloading files from your tenant from untrusted devices and calculate the percentage of downloads from those users vs all untrusted downloads. Useful to see if you have a few users responsible for most of the downloads in your tenant.

//Data connector required for this query - Office 365
//Data connector required for this query - Azure Active Directory - Signin Logs

SigninLogs
| where TimeGenerated > ago(30d)
| where ResultType == 0
| where UserType == "Member"
| extend DeviceTrustType = tostring(DeviceDetail.trustType)
| distinct UserPrincipalName, IPAddress, DeviceTrustType
| join kind=inner(
    OfficeActivity
    | where TimeGenerated > ago(30d)
    | where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
    )
    on $left.UserPrincipalName == $right.UserId, $left.IPAddress == $right.ClientIP
| where isempty(DeviceTrustType)
| summarize Count=count() by UserPrincipalName
| as T
| extend Percentage = round(100.0 * Count / toscalar (T
    | summarize sum(Count)), 2)
| project-reorder UserPrincipalName, Count, Percentage
| top 20 by Percentage desc 
//Detect when a new Exchange admin role is created and parse the permissions

//Data connector required for this query - Office 365

OfficeActivity
| where Operation == "New-RoleGroup"
| where RecordType == "ExchangeAdmin"
| parse Parameters with * 'Name","Value":"' ['Role Name'] '"' *
| parse Parameters with * 'Roles","Value":"' ['Permissions Added'] '"' *
| project TimeGenerated, Actor=UserId, ['Role Name'], ['Permissions Added']
//Detect when a guest is added to multiple Teams in a short time frame.

//Data connector required for this query - Office 365

//Define a time period to check and the threshold of how many Teams to alert on.
let timeframe=15m;
let threshold=2;
OfficeActivity
| where TimeGenerated > ago(1d)
| where Operation == "MemberAdded"
| mv-expand Members
| extend UserAdded = tostring(Members.UPN)
| where UserAdded contains "#EXT#"
| where CommunicationType == "Team"
| summarize
    ['Number of Teams Guest Added To']=dcount(TeamName), ['Team Names']=make_set(TeamName) by UserAdded, bin(TimeGenerated, timeframe)
| where ['Number of Teams Guest Added To'] >= threshold
//Detect when a shared Teams channel is created

//Data connector required for this query - Office 365

OfficeActivity
| where Operation == "ChannelAdded"
| where ChannelType == "Shared"
| project TimeGenerated, Actor=UserId, TeamName, ChannelType, ChannelName
//Detect when an app is installed into Teams for the first time compared to the previous timerange

//Data connector required for this query - Office 365

let knownapps=
    OfficeActivity
    | where TimeGenerated > ago(180d) and TimeGenerated < ago(7d)
    | where OfficeWorkload == "MicrosoftTeams"
    | where Operation == "AppInstalled"
    | distinct AzureADAppId;
OfficeActivity
| where TimeGenerated > ago (7d)
| where OfficeWorkload == "MicrosoftTeams"
| where Operation == "AppInstalled"
| where AzureADAppId !in (knownapps)
| project TimeGenerated, UserId, AddonName, AzureADAppId
//Detect when an Exchange admin grants full mailbox access to another user

//Data connector required for this query - Office 365

OfficeActivity
| where RecordType == "ExchangeAdmin"
| where Operation == "Add-MailboxPermission"
| parse-where Parameters with * 'Identity","Value":"' TargetMailbox '"' *
| parse-where Parameters with * 'User","Value":"' UserGivenAccess '"' *
| parse-where Parameters with * 'AccessRights","Value":"' AccessRights '"' *
| project
    TimeGenerated,
    Actor=UserId,
    ['Target Mailbox']=TargetMailbox,
    ['Target Mailbox DisplayName']=OfficeObjectId,
    ['User Granted Access']=UserGivenAccess,
    ['Access Type']=AccessRights
| where tolower(Actor) != "nt authority\\system (microsoft.exchange.servicehost)"
| sort by TimeGenerated desc 

//Detect when the role for a user changes to owner or back to standard member in your any of your Teams

//Data connector required for this query - Office 365

OfficeActivity
| where Operation == "MemberRoleChanged"
| mv-expand Members
| extend User = tostring(Members.UPN)
| extend x = tostring(Members.Role)
| extend Action = case(x == "1", strcat("User changed to member"),
    x == "2", strcat("User changed to owner"), "unknown")
| where Action in ("User changed to member", "User changed to owner")
| project
    TimeGenerated,
    TeamName,
    ActorType=UserType,
    Actor=UserId,
    UserAdded=User,
    Action
//Summarize the total count and the list of files downloaded by guests in your Office 365 tenant

//Data connector required for this query - Office 365

let timeframe=7d;
OfficeActivity
| where TimeGenerated > ago(timeframe)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
| summarize
    ['Count of Downloads']=count(),
    ['List of Files Downloaded']=make_set(OfficeObjectId)
    by UserId
| sort by ['Count of Downloads'] desc 
//Calculate the percentage that each guest domain is contributing to total downloads from your Office 365 tenant

//Data connector required for this query - Office 365

OfficeActivity
| where TimeGenerated > ago(30d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#EXT#"
| extend ['Guest UserPrincipalName'] = tostring(split(UserId, "#")[0])
| extend ['Guest Domain'] = tostring(split(['Guest UserPrincipalName'], "_")[-1])
| summarize Count=count() by ['Guest Domain']
| as T
| extend Percentage = round(100.0 * Count / toscalar (T
    | summarize sum(Count)), 2)
| project-reorder ['Guest Domain'], Count, Percentage
| sort by Percentage desc 
//Detect when a user shares multiple files to Azure AD guests over a short time frame.

//Data connector required for this query - Office 365

//Define a time period to check and the threshold of how many files to alert on.
//In this example it would detect when a user shares 10 or more files to a guest within 30 minutes
let timeframe=30m;
let threshold=10;
OfficeActivity
| where TimeGenerated > ago(1d)
| where Operation in ("SecureLinkCreated", "AddedToSecureLink")
| where TargetUserOrGroupType == "Guest" or TargetUserOrGroupName contains "#EXT#"
| summarize
    ['File Share Count']=dcount(OfficeObjectId),
    ['List of Files']=make_set(OfficeObjectId)
    by UserId, bin(TimeGenerated, timeframe)
| where ['File Share Count'] >= threshold
//Detect when a new scoping policy is applied, scoping policies are used to limit permissions to Exchange mailboxes being accessed via OAuth. They should be configured with least privilege

//Data connector required for this query - Office 365

OfficeActivity
| where Operation == "New-ApplicationAccessPolicy"
| extend GroupPolicyAppliedTo = tostring(parse_json(Parameters)[1].Value)
| extend AppId = tostring(parse_json(Parameters)[0].Value)
| extend AccessRight = tostring(parse_json(Parameters)[2].Value)
| project TimeGenerated, Actor=UserId, Operation, AccessRight, GroupPolicyAppliedTo, AppId
//Find senders that are potentially spamming your users for the first time. Useful at detecting business email compromise from partner companies.

//Data connector required for this query - M365 Defender - Email* tables

//Set a threshold of the same email being received within a 10 minute period
//Microsoft Sentinel query
let threshold = 500;
//First create a list of sender addresses that have previously sent you bulk email, hopefully this will let us exclude corporate communications and newsletters etc
let knownbulkemail=
    EmailEvents
    | where TimeGenerated > ago(30d) and TimeGenerated < ago (1d)
    | project TimeGenerated, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject
    | where EmailDirection == "Inbound"
    | where DeliveryAction == "Delivered"
    | summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(TimeGenerated, 10m)
    | where RecipientCount > threshold
    | distinct SenderFromAddress;
//Look in the last hour for any new senders that have sent over the threshold in a 10 minute period
EmailEvents
| where TimeGenerated > ago(1d)
| project TimeGenerated, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject
| where EmailDirection == "Inbound"
| where DeliveryAction == "Delivered"
| summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(TimeGenerated, 10m)
| where SenderFromAddress !in (knownbulkemail) and RecipientCount > threshold

//Advanced Hunting query

//Data connector required for this query - Advanced Hunting license

let threshold = 500;
//First create a list of sender addresses that have previously sent you bulk email, hopefully this will let us exclude corporate communications and newsletters etc
let knownbulkemail=
    EmailEvents
    | where Timestamp > ago(30d) and Timestamp < ago (1d)
    | project Timestamp, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject
    | where EmailDirection == "Inbound"
    | where DeliveryAction == "Delivered"
    | summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(Timestamp, 10m)
    | where RecipientCount > threshold
    | distinct SenderFromAddress;
//Look in the last hour for any new senders that have sent over the threshold in a 10 minute period
EmailEvents
| where Timestamp > ago(1d)
| project Timestamp, EmailDirection, DeliveryAction, RecipientEmailAddress, SenderFromAddress, Subject
| where EmailDirection == "Inbound"
| where DeliveryAction == "Delivered"
| summarize RecipientCount=dcount(RecipientEmailAddress) by SenderFromAddress, Subject, bin(Timestamp, 10m)
| where SenderFromAddress !in (knownbulkemail) and RecipientCount > threshold
//Visualize how many files are being downloaded from your Office 365 tenant by guest accounts with trend

//Data connector required for this query - Office 365

let StartDate = now(-90d);
let EndDate = now();
OfficeActivity
| where TimeGenerated > ago(90d)
| where Operation in ("FileSyncDownloadedFull", "FileDownloaded")
| where UserId contains "#ext#"
| make-series TotalDownloads=count() on TimeGenerated in range(StartDate, EndDate, 1d)
| extend (RSquare, SplitIdx, Variance, RVariance, TrendLine)=series_fit_2lines(TotalDownloads)
| project TimeGenerated, TotalDownloads, TrendLine
| render timechart with (title="Guest downloads from Office 365 per day over time with trend")
